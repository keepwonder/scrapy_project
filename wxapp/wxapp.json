{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "微信小程序中的ios兼容性问题 ", "author": "Rolan", "pub_time": "2018-11-1 00:32", "content": "1.ios中input的placeholder属性字体不居中对placeholder设置line-height及font-size对input设置高度2.ios中滚动卡顿设置-webkit-overflow-scrolling:touch;3.微信小程序中解决ios中new Date() 时间格式不兼容在实现倒计时，根据后台返回的时间格式转换时，后台返回了时间格式为”2018-11-12 11:12:11”，然后利用new Date() 转换时，ios中无法展示，安卓中显示正常let time = '2018-12-10 11:11:11';\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n   timeRemain1: temporaryTime1,\r\n})\r\n/* 利用正则表达式替换时间中的”-”为”/”即可 */\r\nlet time = '2018-12-10 11:11:11';\r\nlet temporaryTime = new Date(time.replace(/-/g,'/'));\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n    timeRemain: temporaryTime,\r\n    timeRemain1: temporaryTime1,\r\n })4. 微信小程序scroll-view隐藏滚动条方法在wxss里加入以下代码：::-webkit-scrollbar{\r\nwidth: 0;\r\nheight: 0;\r\ncolor: transparent;\r\n}暂时遇到的兼容性就是这么多，会持续更新，若大家有遇到，可在评论区告知下，感谢正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断ios和Android及PC端实现文字的省略号纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2018-10-30 00:23", "content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费netwjx曹宇   https://juejin.im/post/5bcd5df7518825780d09b145"}
{"title": "小程序选人控件 - 仿企业微信实现多层级无规则嵌套 ", "author": "Rolan", "pub_time": "2018-10-30 00:12", "content": "在很多系统中都有选择联系人的需求，市面上也没什么好的参照，产品经理看企业微信的选人挺好用的，就说参照这个做一个吧。。。\r\n\r\n算了，还是试着做吧，企业微信的选人的确做的挺好，不得不佩服。\r\n先看看效果图吧，多层级无规律的嵌套都能搞定\r\n\r\n一、设计解读\r\n\r\n整个界面分为三部分：\r\n\r\n最上面的返回上一层按钮\r\n中间的显示部门、人员的列表\r\n最下面显示和操作已选人员的 footer。\r\n\r\n为什么加一个返回上一层按钮呢？\r\n我也觉得比较丑，但小程序无法直接控制左上角返回键（自定义 Title 貌似可以，没试过），点左上角的返回箭头的话就退出选人控件到上个页面了。\r\n我们的需求是点击一个文件夹，通过刷新当前列表进入下一级目录，感觉像是又进了一个页面，但其实并没有，只是列表的数据变化了。由此实现不定层级、无规律的部门和人员嵌套的支持。\r\n比如先点击了首屏数据的第二个 item，它的 index 是 1 ，就将 1 存入  indexList ；返回上一层时将最后一个元素删除。\r\n当勾选了某个人或部门时，会在底部的框中显示所有已选人员或部门的名字，当文字超过屏幕宽度时可以向右无限滑动，底部 footer 始终保持一行。\r\n最终选择的人以底部 footer 里显示的为准，点击确定时根据业务需要将已选人员数据发送给需要的界面。\r\n二、功能逻辑分析\r\n先看看数据格式\r\n{\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\n复制代码所有的数据组成一个数据树，子节点嵌套在父节点下。\r\nid,  name 不说了，parentId 指明它的父节点，children 包含它的所有子节点，checked 用来判断勾选状态，isPeople 判断是部门还是人员，因为两者的图标不一样。\r\n注意：\r\n本控件采用了数据分步加载的模式，除了最上层固定的几个分类，其他的每层数据都是点击具体的部门后才去请求服务器加载本部门下的数据的，然后再拼接到原始数据树上。这样可以提高加载速度，提升用户体验。\r\n我也试了一次性把所有数据都拉下来，一是太慢，得三五秒，二是数据量太大的话（我这里应该是超过1000，阈值多少没测过），setData() 的时候就会报错：\r\n\r\n超过最大长度了。。。所以只能分步加载数据。\r\n当然如果你的数据量小，几十人或几百人，也可以选择一次性加载。\r\n这个控件逻辑上还是比较复杂的，要考虑的细节太多……下面梳理一下主要的逻辑点\r\n主要逻辑点\r\n1. 需要一个数组存储所有被点击的部门在当前列表的索引 index ，这里用 indexList 表示\r\n点击某个部门进入下一层目录时，将被点击部门的 index 索引 push  进 indexList  中。点击返回上一层按钮时，删除  indexList 中最后一个元素。\r\n2. 要动态的更新当前列表 currentList\r\n每进入新的一层，或返回上一层，都需要刷新 currentList 来实现页面的更新。知道下一层数据很容易，直接取被点击 item 的 children 赋值给 currentList 即可。\r\n但如何还原上一层的数据呢？\r\n第一点记录的 indexList 就发挥作用了，原始数据树为 originalList，循环遍历 indexList ，根据索引依次取出每层的 currentList 直到 indexList 的最后一个元素，就得到了返回上一层需要显示的数据。\r\n3. 每一次勾选或取消选中都要更新原始的数据树 originalList\r\n页面是根据每个 item 的 checked 属性判断是否选中的，所以每次改变勾选状态都要设置被改变的 item 的 checked 属性，然后更新 originalList。这样即使返回上一层了，再进到当前层级选中状态还会被保留，否则刷新 currentList 后已选状态将丢失。\r\n4. 列表中选择状态的改变与底部 footer 的双联动\r\n我们期望的效果是，选中currentList 列表的某一项，底部 footer 会自动添加被选人的名字。取消选中，底部 footer 也会自动删除。\r\n也可以通过 footer 来删除已选人，点击 footer 中人名，会将此人从已选列表中删除，currentList 列表中也会自动取消勾选状态。\r\n嗯，这个功能比较耗性能，每一次都需要大量的计算。考虑到性能和速度因素，本次只做了从 footer 删除只更新 currentList 的勾选状态。\r\n什么意思呢？假如有两层，A 和 B，B 是 A 的下一层数据，即 A 是 B 的父节点。在 A 中选中了一个部门 校长室，点击下一层到 B，在 B 中又选了两个人 张三 和 李四，这时底部 footer 里显示的应该是三个： 校长室、 张三 、 李四。此时点击 footer 的 张三 ， footer 会把 张三 删除，中间列表中 张三 会被置为未选中状态，这没问题。但点击 footer 的 校长室 , 在 footer 中是把  校长室 删除了，但再返回到上一层时，中间列表中的 校长室 依然是勾选状态，因为此时没有更新原始数据树 originalList。如果觉得这是个 bug, 可以加个更新 originalList 的操作。这样就要遍历  originalList 的每个元素判断与本次删除的 id 是否相等，然后改变 checked 值，如果数据量很大，会非常慢。我做了妥协……\r\n关键的逻辑就这四块了，当然还有很多小细节，直接看代码吧，注释写的也比较详细。\r\n三、代码\r\n目录结构：\r\n\r\nfooter 文件夹下是抽离出的 footer 组件，userSelect 是选人控件的主要逻辑。把这几个文件复制过去就可以用了。\r\n把 userSelect.js 里网络请求的代码替换为你的请求代码，注意数据的字段名是否一致。\r\nuserSelect 的代码\r\n\r\nuserSelect.js\r\n\r\n\r\nimport API from '../../../utils/API.js'\r\nimport ArrayUtils from '../../../utils/ArrayUtils.js'\r\nimport EventBus from '../../../components/NotificationCenter/WxNotificationCenter.js'\r\n\r\nlet TEACHER_ID = 'teacher';\r\nlet TEACHER_DEPARTMENT_ID = 't_department';\r\nlet TEACHER_SUBJECT_ID = 't_subject';\r\nlet TEACHER_GRADECLASS_ID = 't_gradeclass';\r\nlet STUDENT_ID = 'student';\r\nlet PARENT_ID = 'parent'\r\n\r\nlet TEACHER = {\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\nlet STUDENT = {\r\n  id: STUDENT_ID,\r\n  name: '学生',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet PARENT = {\r\n  id: PARENT_ID,\r\n  name: '家长',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet ORIGINAL_DATA = [\r\n  TEACHER, STUDENT, PARENT\r\n]\r\n\r\nPage({\r\n  data: {\r\n    currentList: [], //当前展示的列表\r\n    selectList: [],  //已选择的元素列表\r\n    originalList: [], //最原始的数据列表\r\n    indexList: [],  //存储目录层级的数组，用于准确的返回上一层\r\n    selectList: [],  //已选中的人员列表\r\n  },\r\n\r\n  onLoad: function (options) {\r\n    wx.setNavigationBarTitle({\r\n      title: '选人控件'\r\n    })\r\n    this.init();\r\n  },\r\n\r\n  init(){\r\n    //用户的单位id\r\n    this.unitId = getApp().globalData.userInfo.unitId;\r\n    //用户类型\r\n    this.userType = 0;\r\n    //上次选中的列表，用于判断是不是取消选中了\r\n    this.lastTimeSelect = []\r\n\r\n    this.setData({\r\n      currentList: ORIGINAL_DATA, //当前展示的列表\r\n      originalList: ORIGINAL_DATA, //最原始的数据列表\r\n    })\r\n  },\r\n\r\n  clickItem(res){\r\n    console.log(res)\r\n    let index = res.currentTarget.id;\r\n    let item = this.data.currentList[index]\r\n\r\n    console.log(\"item\", item)\r\n\r\n    if (!item.isPeople) {\r\n      //点击教师，下一层数据是写死的，不用请求接口\r\n      if (item.id === TEACHER_ID) {\r\n        this.userType = 2;\r\n        this.setData({\r\n          currentList: item.children\r\n        })\r\n      } else if (item.id === TEACHER_SUBJECT_ID) {\r\n        if (item.children.length === 0){\r\n          this._getTeacherSubjectData()\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_DEPARTMENT_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherDepartmentData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_GRADECLASS_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === STUDENT_ID) {\r\n        this.userType = 1;\r\n        if (item.children.length === 0) {\r\n          this._getStudentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === PARENT_ID) {\r\n        this.userType = 3;\r\n        if (item.children.length === 0) {\r\n          this._getParentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else{\r\n        //children的长度为0时，请求服务器\r\n        if(item.children.length === 0){\r\n          this._getUserByGroup(item)\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      }\r\n\r\n      //将当前的索引存入索引目录中。索引多一个表示目录多一级\r\n      let indexes = this.data.indexList\r\n      indexes.push(index)\r\n      //是目录不是具体的用户\r\n      this.setData({\r\n        indexList: indexes\r\n      })\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n\r\n  //返回按钮\r\n  goBack() {\r\n    let indexList = this.data.indexList\r\n    if (indexList.length > 0) {\r\n      //返回时删掉最后一个索引\r\n      indexList.pop()\r\n      if (indexList.length == 0) {\r\n        //indexList长度为0说明回到了最顶层\r\n        this.setData({\r\n          currentList: this.data.originalList,\r\n          indexList: indexList\r\n        })\r\n      } else {\r\n        //循环将当前索引的对应数组赋值给currentList\r\n        let list = this.data.originalList\r\n        for (let i = 0; i < indexList.length; i++) {\r\n          let index = indexList[i]\r\n          list = list[index].children\r\n        }\r\n        this.setData({\r\n          currentList: list,\r\n          indexList: indexList\r\n        })\r\n      }\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n  //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n  setLastTimeSelectList(){\r\n    this.lastTimeSelect = []\r\n    this.data.currentList.forEach(item => {\r\n      if (item.checked) {\r\n        this.lastTimeSelect.push(item)\r\n      }\r\n    })\r\n  },\r\n\r\n  //获取教师部门数据\r\n  _getTeacherDepartmentData() {\r\n    this._commonRequestMethod(2, 'department')\r\n  },\r\n\r\n  //请求教师的学科数据\r\n  _getTeacherSubjectData(){\r\n    this._commonRequestMethod(2, 'subject')\r\n  },\r\n\r\n  //请求教师的年级班级\r\n  _getTeacherGradeClassData() {\r\n    this._commonRequestMethod(2, 'gradeclass')\r\n  },\r\n\r\n  //请求学生的年级班级\r\n  _getStudentGradeClassData() {\r\n    this._commonRequestMethod(1, 'gradeclass')\r\n  },\r\n\r\n  //请求家长的年级班级\r\n  _getParentGradeClassData() {\r\n    this._commonRequestMethod(3, 'gradeclass')\r\n  },\r\n\r\n  //根据部门查询人\r\n  _getUserByGroup(item){\r\n    let params = {\r\n      userType: this.userType,\r\n      unitId: this.unitId,\r\n      groupType: item.type,\r\n      groupId: item.id\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUserByGroup(), params, result => {\r\n      console.log('result', result)\r\n      let list = this.transformData(result.data.data, item.id)\r\n      this.setData({\r\n        currentList: list\r\n      })\r\n      this.addList2DataTree()\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //通用的请求部门方法\r\n  _commonRequestMethod(userType, groupType){\r\n    wx.showLoading({\r\n      title: '',\r\n    })\r\n    let params = {\r\n      userType: userType,\r\n      unitId: this.unitId,\r\n      groupType: groupType\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUsersByUserGroupsTree(), params, result => {\r\n      console.log('result', result)\r\n      wx.hideLoading()\r\n      let data = result.data.data\r\n      this.setData({\r\n        currentList: data\r\n      })\r\n      this.addList2DataTree();\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //将请求的数据转化为需要的格式\r\n  transformData(list, parentId){\r\n    //先将数据转化为固定的格式\r\n    let newList = []\r\n    for(let i=0; i<list.length; i++){\r\n      let item = list[i]\r\n      newList.push({\r\n        id: item.id,\r\n        name: item.realName,\r\n        parentId: parentId,\r\n        checked: false,\r\n        isPeople: true,\r\n        userType: item.userType,\r\n        gender: item.gender,\r\n        children: []\r\n      })\r\n    }\r\n    return newList;\r\n  },\r\n\r\n  //将当前列表挂载在原数据树上, 目前支持5层目录，如需更多接着往下写就好\r\n  addList2DataTree(){\r\n    let currentList = this.data.currentList;\r\n    let originalList = this.data.originalList;\r\n    let indexes = this.data.indexList\r\n    switch (indexes.length){\r\n      case 1: \r\n        originalList[indexes[0]].children = currentList\r\n        break;\r\n      case 2:\r\n        originalList[indexes[0]].children[indexes[1]].children = currentList\r\n        break;\r\n      case 3:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children = currentList\r\n        break;\r\n      case 4:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children = currentList\r\n        break;\r\n      case 5:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children[indexes[4]].children = currentList\r\n        break;\r\n    }\r\n\r\n    this.setData({\r\n      originalList: originalList\r\n    })\r\n    console.log(\"originalList\", originalList)\r\n  },\r\n\r\n  //选框变化回调\r\n  checkChange(res){\r\n    console.log(res)\r\n    let values = res.detail.value\r\n    let selectItems = []\r\n    //将值取出拼接成 id，name 格式\r\n    values.forEach(value => {\r\n      let arrs = value.split(\",\")\r\n      selectItems.push({id: arrs[0], name: arrs[1]})\r\n    })\r\n    console.log(\"selectItems\", selectItems)\r\n    console.log(\"lastTimeSelect\", this.lastTimeSelect)\r\n    \r\n    //将本次选择的与上次选择的比对，本次比上次多说明新增了，本次比上次少说明删除了，找出被删除的那条数据，在footer中也删除\r\n    if (selectItems.length > this.lastTimeSelect.length){\r\n      //将 selectList 与 selectItems 拼接并去重\r\n      let newList = this.data.selectList.concat(selectItems)\r\n      newList = ArrayUtils.checkRepeat(newList)\r\n      this.setData({\r\n        selectList: newList\r\n      })\r\n    }else{\r\n      //找出取消勾选的item，从selectList中删除\r\n      //比对出取消勾选的是哪个元素\r\n      let diffItem = {}\r\n      this.lastTimeSelect.forEach(item => {\r\n        let flag = false;\r\n        selectItems.forEach(item2 => {\r\n          if(item.id === item2.id){\r\n            flag = true\r\n          }\r\n        })\r\n        if(!flag){\r\n          diffItem = item\r\n          console.log(\"diff=\", item)\r\n        }\r\n      })\r\n      //找出被删除的元素在 selectList 中的位置\r\n      let list = this.data.selectList\r\n      let delIndex = 0;\r\n      for(let i=0; i<list.length; i++){\r\n        if (list[i].id === diffItem.id){\r\n          delIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      //从list中删除这个元素\r\n      list.splice(delIndex, 1)\r\n      this.setData({\r\n        selectList: list\r\n      })\r\n    }\r\n    console.log(\"selectList\", this.data.selectList)\r\n    //更新 currentList 选中状态并重新挂载在数据树上，以保存选择状态\r\n    this.updateCurrentList(this.data.currentList, this.data.selectList)\r\n  },\r\n\r\n  //footer点击删除回调\r\n  footerDelete(res){\r\n    console.log(res)\r\n    this.setData({\r\n      selectList: res.detail.selectList\r\n    })\r\n\r\n    console.log('selectList', this.data.selectList)\r\n    this.updateCurrentList(this.data.currentList, res.detail.selectList)\r\n  },\r\n\r\n  //点击 footer 的确定按钮提交数据\r\n  submitData(res){\r\n    let selectList = this.data.selectList\r\n    //通过 WxNotificationCenter 发送选择的结果通知\r\n    EventBus.postNotificationName(\"SelectPeopleDone\", selectList)\r\n    //将选择结果存入 app.js 的 globalData\r\n    getApp().globalData.selectPeopleList = selectList\r\n    //返回\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n    console.log(\"selectdone\", selectList)\r\n  },\r\n\r\n  //更新 currentList 并将更新后的列表挂载在数据树上\r\n  updateCurrentList(currentList, selectList){\r\n    let newList = []\r\n    currentList.forEach(item => {\r\n      let flag = false;\r\n      selectList.forEach(item2 => {\r\n        if (item.id === item2.id) {\r\n          flag = true\r\n        }\r\n      })\r\n      if (flag) {\r\n        item.checked = true\r\n      } else {\r\n        item.checked = false\r\n      }\r\n      newList.push(item)\r\n    })\r\n    this.setData({\r\n      currentList: newList\r\n    })\r\n    this.addList2DataTree()\r\n    this.setLastTimeSelectList()\r\n  }\r\n})\r\n复制代码\r\nuserSelect.wxml\r\n\r\n<view class='container'>\r\n  <view class='btn-wrapper'>\r\n    <button bindtap='goBack'>返回上一层</button>\r\n  </view>\r\n\r\n  <view class='people-wrapper'>\r\n    <scroll-view scroll-y class='scrollview'>\r\n      <checkbox-group bindchange=\"checkChange\">\r\n        <view class='item' wx:for='{{currentList}}' wx:key='{{item.id}}'>\r\n          <checkbox checked='{{item.checked}}' value='{{item.id + \",\" + item.name}}'>\r\n          </checkbox>\r\n          <view id='{{index}}' class='item-content' bindtap='clickItem'>\r\n            <image class='img' wx:if='{{!item.isPeople}}' src='../../../assets/file.png'></image>\r\n            <image class='avatar' wx:if='{{item.isPeople}}' src='../../../assets/avatar.png'></image>\r\n            <text class='itemtext'>{{item.name}}</text>\r\n          </view>\r\n        </view>\r\n      </checkbox-group>\r\n      <view class='no-data' wx:if='{{currentList.length===0}}'>暂无数据</view>\r\n    </scroll-view>\r\n  </view>\r\n  <view class='footer'>\r\n    <footer list='{{selectList}}' binddelete='footerDelete' bindsubmit=\"submitData\"/>\r\n  </view>\r\n</view>\r\n复制代码\r\nuserSelect.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 20rpx;\r\n  overflow-x: hidden;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n}\r\n\r\n.btn-wrapper {\r\n  width: 100%;\r\n  padding: 0 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.btn {\r\n  font-size: 24rpx;\r\n  width: 100%;\r\n}\r\n\r\n.people-wrapper {\r\n  width: 100%;\r\n  margin-top: 10rpx;\r\n  margin-bottom: 100rpx;\r\n}\r\n\r\n.scrollview {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.item {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  padding: 30rpx 0;\r\n  margin: 0 20rpx;\r\n  border-bottom: 1rpx solid rgba(7, 17, 27, 0.1);\r\n}\r\n\r\n.item-content {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.itemtext {\r\n  font-size: 36rpx;\r\n  color: #333;\r\n  margin-left: 20rpx;\r\n  text-align: center;\r\n}\r\n\r\n.img {\r\n  width: 50rpx;\r\n  height: 40rpx;\r\n}\r\n\r\n.avatar {\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n\r\n.footer {\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n}\r\n\r\n.no-data{\r\n  width: 100%;\r\n  font-size: 32rpx;\r\n  text-align: center;\r\n  padding: 40rpx 0;\r\n}\r\n复制代码\r\nuserSelect.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"footer\": \"footer/footer\"\r\n  }\r\n}\r\n复制代码footer 的代码\r\n\r\nfooter.js\r\n\r\n\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    list: {\r\n      type: Array\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    delete(res){\r\n      console.log(res)\r\n      let index = res.currentTarget.id\r\n      let list = this.data.list\r\n      list.splice(index,1)\r\n      this.setData({list: list})\r\n      this.triggerEvent(\"delete\", {selectList: list})\r\n    },\r\n\r\n    /**\r\n     * 点击确定按钮\r\n     */\r\n    confirm(){\r\n      this.triggerEvent(\"submit\", \"\")\r\n    }\r\n  }\r\n})\r\n复制代码\r\nfooter.wxml\r\n\r\n<view class='container'>\r\n  <view class='scroll-wrapper'>\r\n    <scroll-view scroll-x style='scroll'>\r\n      <text id='{{index}}' class='text' wx:for='{{list}}' wx:key='{{index}}' bindtap='delete'>{{item.name}}</text>\r\n    </scroll-view>\r\n  </view>\r\n  <text class='btn' bindtap='confirm'>确定</text>\r\n</view>\r\n复制代码\r\nfooter.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 20rpx;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n  align-items: center;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n  border-top: 2rpx solid rgba(7, 17, 27, 0.1)\r\n}\r\n\r\n.scroll-wrapper {\r\n  flex: 1;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n}\r\n\r\n.scroll {\r\n  width: 100%;\r\n\r\n}\r\n\r\n.text {\r\n  font-size: 32rpx;\r\n  color: #333;\r\n  padding: 40rpx 20rpx;\r\n  margin-right: 10rpx;\r\n  background-color: #f5f5f5;\r\n}\r\n\r\n.btn {\r\n  padding: 10rpx 20rpx;\r\n  background-color: rgb(26, 173, 25);\r\n  border-radius: 10rpx;\r\n  font-size: 32rpx;\r\n  color: #fff;\r\n}\r\n复制代码\r\nfooter.json\r\n\r\n{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码再补一个用到的 ArrayUtils 的代码\r\nexport default{\r\n\r\n  /**\r\n     * 给数组去重\r\n     */\r\n  checkRepeat(list) {\r\n    let noRepList = [list[0]]\r\n    for (let i = 0; i < list.length; i++) {\r\n      let repeat = false\r\n      for (let j = 0; j < noRepList.length; j++) {\r\n        if (noRepList[j].id === list[i].id) {\r\n          repeat = true\r\n          break\r\n        }\r\n      }\r\n      if (!repeat) {\r\n        noRepList.push(list[i])\r\n      }\r\n    }\r\n    return noRepList\r\n  },\r\n\r\n  //删除list中id为 delId 的元素\r\n  deleteItemById(list, delId){\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (list[i].id == delId) {\r\n        list.splice(i, 1)\r\n        return list;\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n}\r\n复制代码由于时间紧张，还没有把这个控件单独从项目中抽出来写个 Demo，有时间了会给 github 地址的。\r\n代码还有很多可以优化的地方，比如有几个方法太长了，不符合单一职责原则等等，不想改了，以后再优化吧。。\r\n水平有限，各位大侠请轻喷~\r\n有问题或发现 Bug 请在评论区留言，毕竟刚写完就分享出来了，还没经过严格的测试。不过应该没什么大的问题。。。有些细节可能没注意到。\r\n关注下面的标签，发现更多相似文章作者：solocoder链接：https://juejin.im/post/5bd3ec0551882528382d8028"}
{"title": "微信小程序仿微信SlideView组件slide-view ", "author": "Rolan", "pub_time": "2018-11-1 00:52", "content": "微信小程序仿微信SlideView组件。使用1、安装 slide-view从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-slide-view\r\n\r\n2、在需要使用 slide-view 的页面 page.json 中添加 slide-view 自定义组件配置{  \r\n    \"usingComponents\": {    \r\n        \"slide-view\": \"miniprogram-slide-view\"\r\n    }\r\n}\r\n3、WXML 文件中引用 slide-view每一个 slide-view 提供两个<slot>节点，用于承载组件引用时提供的子节点。left 节点用于承载静止时 slide-view 所展示的节点，此节点的宽高应与传入 slide-view 的宽高相同。right 节点用于承载滑动时所展示的节点，其宽度应于传入 slide-view 的 slideWidth 相同。<slide-view class=\"slide\" width=\"320\" height=\"100\" slideWidth=\"200\">\r\n  <view slot=\"left\">这里是插入到组内容</view>\r\n  <view slot=\"right\">\r\n    <view>标为已读</view>\r\n    <view>删除</view>\r\n  </view>\r\n</slide-view>\r\n\r\n参数说明：width：Number类型，默认值显示屏幕的宽度，slide-view组件的宽度height：Number类型，默认值0，slide-view组件的高度slide-width：Number类型，默认值0，滑动展示区域的宽度（默认高度与slide-view相同）运行效果其他slide-view项目地址：https://github.com/wechat-min..."}
{"title": "微信小程序之物流状态时间轴 ", "author": "Rolan", "pub_time": "2018-11-1 00:16", "content": "一个月左右没更新博客了，最近有点懒了哈（工作上真的忙），很多工作上学习到的东西都没有及时分享出来，有点愧疚，不过自己最近一直在收集资料和学习一些新技术，最主要是想要构建自己的前端技术体系和自定义一个前端规范文档，哈哈哈。说重点啦，微信小程序里面开发的商城模块还挺多的，刚好写了一个物流状态的时间轴，简单分享一下哈。（一）实现效果真机测试的结果（图片忘记缩小了）（二）实现分析页面布局拆分：简单的说：就是父级容器下，左边的子级容器是设置绝对定位（记得父级要设置相对定位哈），然后自己调位置，中间子级容器下放三个子容器（设置时间轴线、点的样式），右边的子级容器设置； wxml代码有备注信息 。（三）实现代码1、wxml代码：<view class='g_con'>\r\n\r\n  <view class='topExpress'>\r\n\r\n    <view class='topExpress-left'>\r\n      <image src='/images/Exchange_goods_map_1.png' style='width:60rpx;height:60rpx;border-radius:50%;'></image>\r\n    </view>\r\n    <view class='topExpress-right'>\r\n      <view class='topExpress-right-top'>圆通速递</view>\r\n      <view class='topExpress-right-middle'>运单号：813291235464788594</view>\r\n      <view class='topExpress-right-bottom'>官方电话 95554 ></view>\r\n    </view>\r\n\r\n  </view>\r\n\r\n  <!-- 物流时间轴 -->\r\n  <view class='expressRecord'>\r\n\r\n\r\n    <!-- 顶部收货地址 -->\r\n    <view class='expressRecord-getAddress'>\r\n      <view class='expressRecord-top'>\r\n        <view class='getAddress-icon'>\r\n          收\r\n        </view>\r\n        <view class='getAddress-text'>[收货地址] 广东省深圳市南山区 南山街道 亿利达大厦</view>\r\n      </view>\r\n    </view>\r\n\r\n    <!-- 顶部收货地址半个时间轴线 -->\r\n    <view class='noReach-online-top-close'></view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：当前正在进行的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n\r\n      <!-- 左边子容器 -->\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <!-- 正在进行的时间轴上半个时间线 -->\r\n        <view class='online-top-closing'></view>\r\n        <!-- 正在进行的时间轴点 -->\r\n        <view class='dot-closing'></view>\r\n        <!-- 正在进行的时间轴下半个时间线 -->\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <!-- 右边子容器 -->\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-statusing'>运输中</view>\r\n        <view class='expressRecord-status-addressing'>武汉转运中心公司 已发出，下一站 深圳转运中心</view>\r\n      </view>\r\n\r\n      <!-- 相对父级容器绝对定位的日期 -->\r\n      <view class='expressRecord-dating'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:39\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：已经过去的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>武汉转运中心公司 已收入</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已打包</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已揽件</view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已收件</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:17\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <!-- 起始位置，下半个时间轴线不用 -->\r\n        <view class='online-bottom-start'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已发货</view>\r\n        <view class='expressRecord-status-address'>卖家发货</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          13:50\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  </view>\r\n\r\n\r\n\r\n</view>\r\n复制代码2、wxss代码：page {\r\n  background: #f4f4f4;\r\n}\r\n\r\n.g_con {\r\n  width: 100vw;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.topExpress {\r\n  width: 710rpx;\r\n  height: 155rpx;\r\n  background: #fff;\r\n  margin: 10rpx auto;\r\n  display: flex;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.topExpress-left {\r\n  width: 100rpx;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.topExpress-right {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  padding: 20rpx 0;\r\n}\r\n\r\n.topExpress-right-middle {\r\n  font-size: 22rpx;\r\n}\r\n\r\n.topExpress-right-bottom {\r\n  font-size: 20rpx;\r\n  color: #666;\r\n}\r\n\r\n.expressRecord {\r\n  width: 710rpx;\r\n  padding-top: 30rpx;\r\n  padding-bottom: 200rpx;\r\n  background: #fff;\r\n  margin: 0 auto;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.expressRecord-getAddress {\r\n  width: 100%;\r\n  font-size: 22rpx;\r\n  color: #999;\r\n  display: flex;\r\n}\r\n\r\n.expressRecord-top {\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n}\r\n\r\n.getAddress-icon {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n  border-radius: 50%;\r\n  background: #999;\r\n  font-size: 18rpx;\r\n  color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-left: 80rpx;\r\n}\r\n\r\n.getAddress-text {\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.noReach-online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-single-close {\r\n  width: 100%;\r\n  height: 122rpx;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n\r\n.expressRecord-single-noReach-online-top-close {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.online-top-closing {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.dot-closing {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #fe4f33;\r\n}\r\n\r\n.dot-close {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #999;\r\n}\r\n\r\n.online-bottom {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-bottom-start {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  /* background: #999; */\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-text {\r\n  margin-left: 30rpx;\r\n}\r\n\r\n.expressRecord-statusing {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-status-addressing {\r\n  font-size: 22rpx;\r\n  color: #333;\r\n}\r\n\r\n\r\n.expressRecord-status {\r\n  font-size: 26rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-status-address {\r\n  font-size: 22rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-dating {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-date {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-date-text {\r\n  font-size: 24rpx;\r\n}\r\n\r\n.expressRecord-date-time {\r\n  font-size: 18rpx;\r\n}\r\n\r\n复制代码如果感觉有用的话，点个赞呗，支持一下我哈。"}
{"title": "小程序tabbar这套方案全搞定！ ", "author": "Rolan", "pub_time": "2018-10-31 00:12", "content": "关于微信小程序的tarbar，相信你们都不会陌生 在实现小程序微信原装的tabbar却比较呆板，不够精致，往往不符合自己的要求这个时候怎么办呢这套方案接着！先简单的来说一下主要思想:自定义字体图标组件以及tabbar组件，在tabbar中引用自定义字体图标组件。先说一下这套方案的优点：图片换成字体,体积小,请求减少,性能提高自己定义tabbar,能够从细节各方面达到自己的要求，精确到1像素组件可以根据自己的条件来更换tabbar图标（比如你点进一个页面想把这个页面的tabbar样式自己更换） 总而言之就是自由性很大，精准性良好，能够去随心所欲的打造你的专属tabbar!实现这套方案核心还是自定义组件那就从这开始聊：一个自定义组件由 json wxml wxss js 4个文件组成。一个页面要引用一个组件时只需要在该页面的json配置下添加如下{\r\n//声明引用一个组件 配置好你的组件引用路径\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码然后再页面上添加组件的标签即可。//这样就能够在你的页面中添加组件\r\n<icon type=\"\" color=\"\" size=\"\"/>\r\n复制代码如果对于组件的定义仍有疑惑的可以参考这份文档： 官方关于自定义组件的文档OK 下面我们正式来讲这份方案：先定义字体图标组件，在阿里图标库里面挑选好你所需要的字体选择下载代码。 这里我选择的是其中的_fontclass方案，把iconfont.css内的内容拷贝到你创建的icon目录下的index.wxss3. 将该目录下index.json添加{  \r\n//声明这一组文件设为自定义组件\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码在index.wxml中定义该组件的结构<!-- 注意style里面的分号！ -->\r\n<text class=\"iconfont icon-{{type}}\" style=\"color:{{color}}; font-size:{{size}}rpx\" ></text>\r\n复制代码在js里面配置他的属性//这里定义了3个自定义属性他们通过{{}}与wxml中的数据连接起来\r\n Component({\r\n  properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  }\r\n})\r\n复制代码到此，字体图标组件搞定。现在开始第二步，搞定tabbar组件。首先做在json中添加配置{\r\n  \"component\": true,\r\n  //声明对字体图标组件的引用\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码写wxml结构<view class=\"weibo-tabbar\" >\r\n//绑定回首页事件，此处的data-hi中的数据是为了传递到e.currentTarget.dataset.hi\r\n//通过这个数据我们可以用来判断是否处于首页，然后在js中配置可以阻扰原地跳转\r\n    <view class=\"item-left\"  bindtap=\"goHome\" data-hi=\"{{isIndex}}\">\r\n            <icon type=\"shouye\" color=\"{{isIndex?'#000000':'#b1b1b1'}}\" size=\"45\"/>\r\n            <text class=\"1\" style=\"color:{{isIndex?'#000000':'#b1b1b1'}}\">首页</text>\r\n    </view>\r\n    <block wx:if=\"{{isInner}}\">\r\n        <view class=\"item-right\" style=\"color:#b1b1b1\" bindtap=\"goShare\">\r\n        <icon type=\"fenxiang\" color=\"gray\" size=\"45\"/>\r\n            <text class=\"2\">分享</text>\r\n        </view>\r\n    </block>\r\n    <block wx:else>\r\n        <view class=\"item-right\"  bindtap=\"goInfo\" data-hi=\"{{isIndex}}\">\r\n        <icon type=\"wode\" color=\"{{isIndex?'#b1b1b1':'#000000'}}\" size=\"45\"/>\r\n            <text class=\"2\" style=\"color:{{isIndex?'#b1b1b1':'#000000'}}\">我的</text>\r\n        </view>\r\n    </block>\r\n</view>\r\n复制代码再配置js属性及方法const app = getApp();\r\nComponent({\r\n  properties: {\r\n    isIndex: { // 是否主页            \r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n    isInner: { //是否内部页面\r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    goHome: (e) => {\r\n      // 判断是否为主页面防止原地跳转\r\n      if(!e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    },\r\n    goShare: function () {\r\n    },\r\n    goInfo: (e) => {\r\n        if(e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/info/info\"\r\n        })\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码配置样式wxss.weibo-tabbar {\r\n    bottom: 0;\r\n    height: 97rpx;\r\n    padding: 12rpx 0rpx;\r\n    display: flex;\r\n    width: 100%;\r\n    position: fixed;\r\n    background: #ffffff;\r\n    box-sizing: border-box;\r\n}\r\n//产生优雅的0.5px边框\r\n.weibo-tabbar::after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 200%;\r\n    height: 200%;\r\n    top: 0;\r\n    left: 0;\r\n    border-top: 1rpx solid rgba(177, 177, 177, 0.4);\r\n    transform: scale(0.5);\r\n    transform-origin: 0 0;\r\n  }\r\n  //这里用flex布局，移动端flex布局确实很爽\r\n  .weibo-tabbar .item-left, .item-right{\r\n   //这里有一处坑，若不不设置他的层级变大的话\r\n   //你是点不到这个item按钮的，当然也不会产生触碰事件\r\n    z-index: 999;\r\n    width: 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    font-size: 20rpx;\r\n    color: #b1b1b1;\r\n}\r\n.shouye, .wode {\r\n    height: 45rpx;\r\n    width: 45rpx;\r\n}\r\n复制代码到此你只需要在你的页面优雅的添加一行，就能在你的页面中产生tabbar//此处isIndex是给组件的属性传输值，别属性不添加即为默认属性值\r\n<tabbar isIndex=\"true\"></tabbar>\r\n复制代码结果：哇，看了半天就出这么一个小东西！其实大道至简掌握这套方案能够适配你需要的所有tabbar他的颜色、大小、位置都可以自己掌控，重要的是这个解决方案。最后强调一下里面的一些坑按钮的样式层级z-index要提高属性值与{{}}传输的把握style=\"color:{{color}}; font-size:{{size}}\" 注意里面的;号"}
{"title": "微信小程序之animation底部弹窗动画（两种方法） ", "author": "Rolan", "pub_time": "2018-10-31 00:26", "content": "简单分享一下常用的底部弹窗层或下拉框弹出层（代码需要修改）的内容弹窗的动画效果，这里分享的是点击按钮后底部弹窗的动画效果。第一种方式是动态设置显示区域的高度，第二种方法是动态设置显示区域的移动的位置（使用到 transform:translateY ）；（一）实现效果简单说明一下，两种方法实现的效果是一样的，只有点击按钮才能出发弹窗（指定位置），弹窗弹出后，只有点击背景灰色区域弹窗才能收回，点击弹窗内容区域（粉红色部分是不能收回弹窗的），自己可以自定义粉红色部分右上角关闭按钮。（二）实现分析第一种动态设置高度的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，动态设置内容区域的高度，比如弹出：一开始高度为0（隐藏了），通过animation设置的动画时间，将高度从0到指定高度，内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。第二种动态设置位置的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，比如弹出：一开始粉红色区域的位置平移在屏幕外（隐藏了），通过animation设置的动画时间，将粉红色区域从屏幕外平移到屏幕内（默认设置在屏幕底部的位置），内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。 代码也有注释哈。（三）实现代码第一种动态设置高度方法实现：1、wxml代码：<button catchtap='clickPup'>点击底部动画弹窗</button>\r\n\r\n<!-- 底部弹窗动画的内容 -->\r\n<view class='pupContent {{click? \"showContent\": \"hideContent\"}} {{option? \"open\": \"close\"}}' hover-stop-propagation='true'>\r\n  <view class='pupContent-top'>测试一下</view>\r\n</view>\r\n<!-- 固定的背景 -->\r\n<view class='pupContentBG {{click?\"showBG\":\"hideBG\"}} {{option?\"openBG\":\"closeBG\"}}' catchtap='clickPup'>\r\n</view>\r\n复制代码2、wxss代码：.pupContentBG {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: fixed;\r\n  top: 0;\r\n}\r\n\r\n.pupContent {\r\n  width: 100%;\r\n  background: pink;\r\n  position: absolute;\r\n  bottom: 0;\r\n  box-shadow: 0 0 10rpx #333;\r\n  height: 0;\r\n  z-index: 999;\r\n}\r\n\r\n/* 设置显示的背景 */\r\n\r\n.showBG {\r\n  display: block;\r\n}\r\n\r\n.hideBG {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideBGtUp {\r\n  from {\r\n    background: transparent;\r\n  }\r\n\r\n  to {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n}\r\n\r\n@keyframes slideBGDown {\r\n  from {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n\r\n  to {\r\n    background: transparent;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.openBG {\r\n  animation: slideBGtUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.closeBG {\r\n  animation: slideBGDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n/* 设置显示内容 */\r\n\r\n.showContent {\r\n  display: block;\r\n}\r\n\r\n.hideContent {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    height: 0;\r\n  }\r\n\r\n  to {\r\n    height: 800rpx;\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    height: 800rpx;\r\n  }\r\n\r\n  to {\r\n    height: 0;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.open {\r\n  animation: slideContentUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.close {\r\n  animation: slideContentDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n复制代码3、js代码：data: {\r\n    click: false, //是否显示弹窗内容\r\n    option: false, //显示弹窗或关闭弹窗的操作动画\r\n  },\r\n\r\n  // 用户点击显示弹窗\r\n  clickPup: function() {\r\n    let _that = this;\r\n    if (!_that.data.click) {\r\n      _that.setData({\r\n        click: true,\r\n      })\r\n    }\r\n\r\n    if (_that.data.option) {\r\n      _that.setData({\r\n        option: false,\r\n      })\r\n\r\n      // 关闭显示弹窗动画的内容，不设置的话会出现：点击任何地方都会出现弹窗，就不是指定位置点击出现弹窗了\r\n      setTimeout(() => {\r\n        _that.setData({\r\n          click: false,\r\n        })\r\n      }, 500)\r\n\r\n\r\n    } else {\r\n      _that.setData({\r\n        option: true\r\n      })\r\n    }\r\n  },\r\n\r\n复制代码第二种动态平移内容区域位置方法实现：相对于第一种代码修改的部分：只修改的了粉红色区域的高度和粉红色区域弹出和收回的动画效果：/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    transform: translateY(100%); /*设置为正数则底部弹出来，负数则相反*/\r\n  }\r\n\r\n  to {\r\n    transform: translateY(0%);\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    transform: translateY(0%);\r\n  }\r\n\r\n  to {\r\n    transform: translateY(100%);\r\n  }\r\n}\r\n复制代码参考资料：CSS3（三）Animation 入门详解微信小程序CSS3动画下拉菜单感谢阅读。"}
{"title": "微信小程序多层嵌套循环，三级数组遍历 ", "author": "Rolan", "pub_time": "2018-10-30 00:32", "content": "数据：三层嵌套index.wxml 页面<!-- 菜单标签 -->\r\n<view class='menu_label'>\r\n    <view class='label_ul'>\r\n        <view wx:for=\"{{ menuList }}\" wx:key='' class=\"{{ label_index == index ? 'label_lis' : 'label_li' }}\" bindtap='menuList' id=\"{{ index }}\">{{ item.title }}</view>\r\n    </view>\r\n</view>\r\n\r\n<!-- 图书内容 -->\r\n<view class='book_sec'>\r\n    <view class='book_ul' wx:for=\"{{ bookUl }}\" wx:key='' wx:for-item=\"secUl\"  wx:if=\"{{ label_index == index }}\" id=\"{{ index }}\">\r\n        <view class='book_li' wx:for='{{ secUl.bookSec }}' wx:key='' wx:for-item=\"secLi\">\r\n            <view class='book_ol'>\r\n                <view class='book_ol_li' wx:for='{{ secLi.bookList }}' wx:key='' wx:for-item=\"item\">\r\n                    <view class='book_free b'>免费阅读</view>\r\n                    <image src='{{ item.img }}'></image>\r\n                    <view class='book_people b'>100006人在读</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n\r\n\r\nindex.js页面Page({\r\n        /**\r\n         * 页面的初始数据\r\n         */\r\n        data: {\r\n            menuList: [\r\n                { title: '全部' },\r\n                { title: '文学' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n                { title: '设计' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n            ],\r\n            label_index: 0,\r\n            bookUl: [\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img1_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img3_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img6_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                                { img: '../../img/img4_icon.png' }\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img1_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img3_icon.png' },\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img6_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n            ]\r\n            \r\n            /**\r\n             * 菜单点击切换内容\r\n             */\r\n        \r\n            menuList: function (e) {\r\n                let that = this;\r\n                // console.log(e);\r\n                var id = e.target.id;\r\n                \r\n                that.setData({\r\n                    label_index: id\r\n                })\r\n            } \r\n        },\r\n    })\r\n\r\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。wx:key 的值以两种形式提供1）字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2）保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。最后效果图作者：MRZYD原文：https://segmentfault.com/a/1190000016818075"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-10-31 00:46", "content": "本文由heyli发表于云+社区专栏什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的 云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发 ，开通一下，填写环境 ID ，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true 。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id ，但不可在小程序端自定义（在服务端可以） _openid 。 _openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection 。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection 。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（ appid 、 openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ openid ）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在 云函数 中介绍这两种写法。 Async/Awai t 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};Async/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill ，比如这个开源的项目： regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "pub_time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:46", "content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "pub_time": "2016-10-12 22:49", "content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "pub_time": "2016-10-12 23:08", "content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "pub_time": "2016-10-12 23:22", "content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "pub_time": "2016-10-12 23:26", "content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "pub_time": "2016-10-12 23:31", "content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "pub_time": "2016-10-13 16:49", "content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "微信小程序教程：app配置指南 ", "author": "天下雪", "pub_time": "2016-10-13 17:20", "content": "//app.json页面 {//页面注册，有几个页面都要在pages里面注册\"pages\":[\"pages/index/index\",\"pages/logs/logs\",\"pages/main/main\",\"pages/main1/main1\",\"pages/main2/main2\",\"pages/main3/main3\",],//上导航配置及app背景颜色设置\"window\":{//是否开启下拉刷新\"enablePullDownRefresh\":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见\"backgroundColor\":\"#eee\",//下拉背景字体、loading 图的样式，仅支持 dark/light,（string形式）\"backgroundTextStyle\":\"light\",//上导航条背景颜色\"navigationBarBackgroundColor\": \"orange\",//上导航标题文字\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" //上导航标题字体颜色，仅支持white和black },//底部导航配置\"tabBar\": {\"color\": \"#a9b7b7\",//导航字体默认颜色\"selectedColor\": \"#eb4f38\",//导航字体选中时颜色\"borderStyle\": \"black\", //上border颜色，仅支持 black/white（string形式）\"backgroundColor\": \"rgba(0,0,0,0.4)\",//底部导航背景色\"list\": [ //导航列表2-5个{\"pagePath\": \"pages/index1/index1\", //每个导航的网页对应的路径\"text\": \"首页\", //标题\"iconPath\": \"images/wechat.png\", //默认小图标路径\"selectedIconPath\": \"images/wechatHL.png\" //选中时的小图标路径},{\"pagePath\": \"pages/index2/index2\",\"text\": \"日记\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},{\"pagePath\": \"pages/index3/index3\",\"text\": \"指南\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},]},//网络请求超时时间\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},//是否开启debug模式\"debug\": true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持 black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即: #ffffff 类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；   //app.js页面App({//当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onLaunch: function () {//onLaunch时调用API从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},//获取用户登录信息getUserInfo:function(cb){var that = thisif(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfotypeof cb == \"function\" && cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url: 'test.php',data: {x: 'xxx',y: 'yyy'},header: {'Content-Type': 'application/json'},success: function(res) {console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据 globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例 //其他页面可以通过getApp().globalData.xxx获取到全局数据})  //app.wxss页面.common {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2 伪类::after伪类::before//不支持层级，如.common > view 或者.common view//引入新的单位rpx:rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。及新的rem:rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的"}
{"title": "微信小程序官方文档里看不到的小Tips ", "author": "天下雪", "pub_time": "2016-10-13 17:26", "content": "1. WXML(HTML)　　1.1 小程序的WXML没有HTML的宽容度?那么高，单标签必需是 /> 结尾的。不然会报错。　　1.2 官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class, id, data 这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。　　1.3 scroll-view 的scroll-top, scroll-left 是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变 scroll-top, scroll-left 的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top, scroll-left 的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view 获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view 还是有webview的 scroll 的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top 不为0，设个1就好了。　　1.4 input 目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的 change 事情来获取，甚是麻烦。　　1.5 只有  checkbox-group 有 change 事件，单个的checkbox是没有的，如果你只有一个checkbox， 觉得外面套一个checkbox-group麻烦又不美观的话，可以用 switch type=\"checkbox\" 代替。　　1.6 map 组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if=\"false\" 然后onLoad的之后改成 true 就行了。　　1.7 map, canvas 像是在webview上面盖一个native组件的感觉。它们是没法被overflow 以及 上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas 无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2. WXSS(CSS)　　2.1 WXSS 和 CSS很像，基本所有的CSS都支持，小程序还提供了 rpx 这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出　　2.2 WXSS不支持 大括号嵌套（{{}} ）。所以key-frames，CSS animation 就不可用了，不过transition 是可用的。　　2.3 目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。　　2.4 WXSS中是不能引入本地资源的, 只能使用线上资源（模拟器是可以，但是别信），可以使用base64。　　2.5 WXSS的 rule 是不支持集联的。所以不能 body .main {background:#000;} 这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持 li.current {color: red;} 这样的写法，支持after， before伪类，但是不支持 first-child last-child nth-child 这类伪类。　　2.6 app.wxss 和每个 page 的wxss 的覆盖关系是: 如果有同名 rule 的话，page 会覆盖 app 的，不是merge是覆盖。　　3. JS　　3.1 JS 的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。　　3.2 JS 目前有个很大的问题是无法获取到页面px级的宽度高度, 所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。　　3.3 上面有说过 setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）　　3.4 使用 navigate 跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是 navigate back的时候没有一个官方给出的数据通讯机制。可以使用getApp() 获取到全局对象，给上面加点东西，自行实现。navigate 最多5个什么的就不说了。　　3.5 canvas getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。　　3.6 开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说 auto-focus 能自动呼出键盘就已经是个很大的好评了。"}
{"title": "微信小程序开发准备：必修课程推荐 ", "author": "天下雪", "pub_time": "2016-10-13 18:06", "content": "今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识 HTML，通过 HTML 文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对 HTML 有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构 （网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习 JavaScript 的语法及事件、对象、DOM 等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过 SCSS（SASS）画一个会眨眼睛的小黄人，主要学习 CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的："}
{"title": "微信小程序用户信息解密 C# ", "author": "qq515373375", "pub_time": "2016-10-13 18:24", "content": "背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是 unionid 开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用 wx.login 接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html 实现code 换取 session_key前端先调 wx.login 得到code后端换取session_key和openid， openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用 wx.login， 会导致上一次的 session_key 失效，解密出来的都是乱码　　2. 解密前端先调 wx.getUserInfo 得到encryptData用login返回的openid，encryptData 调后端解密刚开始按开发文档，用C# 系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助 :)"}
{"title": "anjular2和微信小程序的对比 ", "author": "qq515373375", "pub_time": "2016-10-13 18:30", "content": "1条件渲染：小程序：用 wx:if=\"{{condition}}\" 来判断是否需要渲染该代码块。<view wx:if=\"{{condition}}\">　　　　True</view>ng2:  用 *ngIf=\"condition\"来判断是否需要渲染该代码块。<p  *ngIf=\"condition\">　　　　condition is true and ngIf is true.</p>对于ng2, 当=号里面的值为真时才渲染标签内的元素，为假时将元素移除。注意：这里是将元素从DOM树里面完全移除，而不是隐藏。 对于需要频繁切换可见性的元素来说，改变元素的display无疑要比频繁的移除和重新渲染高效的多。 不过，angulra2开发者认为，在大多数 UI中，当我们“关闭”一个组件时，在相当长时间内都不大可能想再见到它——可能永远也不见。 而且，当我们隐藏掉一个元素时，组件的行为还在继续——它仍然附加在它所属的 DOM 元素上， 它也仍在监听事件。 Angular 会继续检查哪些能影响数据绑定的变更。 组件原本要做的那些事情仍在继续。 虽然不可见，组件及其各级子组件仍然占用着资源。  虽然每种方法都有各自的优点和缺点，但使用 ngIf 来移除不需要的组件通常都会比隐藏它们更好一些。微信小程序文档较少，不过根据文档中这段话：一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好可以推测wx:if和*ngIf实质是一样的，虽然在写法上有些区别，wx是将条件包裹在{{ condition }}里面。 2 循环列表渲染小程序：列表渲染：默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item<view wx:for=\"{{items}}\">　　{{index}}: {{item}}</view>如某个数组为[a,b,c,d]，则对应的下标index为0,1,2,3，对应的变量名item为a,b,c,d使用wx:for-item可以指定数组当前元素的变量名；使用wx:for-index可以指定数组当前下标的变量名；如： <view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">　　　　  {{idx}}: {{itemName.message}}      </view>则此时下标idx为0,1,2,3, 变量名itemName为a,b,c,dng2:<div *ngFor=\"let hero of heroes; let i=index\">　　　　{{i + 1}} - {{hero.fullName}}</div>ng2里指定变量名用的是let hero of heroes，即设置变量名为hero，对应微信的 wx:for-item=\"itemName；指定下标let  i=index，对应微信的wx:for-index=\"idx\";上面这种写法实际上已经经过语法糖包装后的写法，原来的写法太啰嗦，形似类似： <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">　　　　<li>...</li></template> 3数据绑定微信：数据绑定使用 Mustache 语法（双大括号）将变量包起来　　　　<view> {{ message }} </view>并在js文件里面设置对应的变量值Page({　　data: {　　　　message: 'Hello MINA!'　　}})微信小程序没有双向数据绑定，要改变变量值时，需要通过setdata改变，监听事件如eventname: function(e) {　　this.setData({　　　　data: \"im_new\"　　})}注意不能这样this.data=\"im_new\"，否则会出错 ng2:ng2:主要看一下双向数据绑定：<input [(ngModel)]=\"currentHero.firstName\">（123）表示绑定事件，[12345]表示绑定数据通过[( )]即可实现双向数据绑定这是种简写的形式，背后是这样写的<input　　　　[ngModel]=\"currentHero.firstName\"　　　　(ngModelChange)=\"currentHero.firstName=$event\">"}
{"title": "微信小程序开发一些经验 ", "author": "Rolan", "pub_time": "2018-5-16 00:14", "content": "对于微信小程序开发入门，还是比较简单的，只需要具备基本的css+js知识就可以了，成本比较低。 写了小程序和RN之后，有一种原生很笨重的感觉，就是小程序或者是RN等这些新的开发方式在效率上面真的有比较大的优势，唯一不足就是运行速度了(使用Canvas就会有这样子的感觉)。 感觉目前所接触的种类前端开发(包括移动端)，都是基本一个套路：UI，网络，数据保存，富文本，图片/视频。 本文也是从这几个方向去总结自己的小程序开发经验。小程序的入门其实小程序的开发过程一直都是查看文档，按照文档去操作就可以了。 一般流程是先看简易教程。看完之后，再去看组件。之后可以开始尝试写需求，这个过程中，开始不断的去查API和框架即可。多列列表在开发中，有一个需求是需要实现类似Android的GridView网格列表的。但是微信中并没有提供这样子的组件，但是小程序是跟html/css前端很类似的，他可以通过指定 display:flex ，然后去设置 flex-wrap:wrap 就可以。例如，有一个数组 data:[\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\"] 需要显示为一个三列的列表，可以如下处理：//GridPage.wxml\r\n<view class='grid-container'>\r\n  <view wx:for=\"{{data}}\" wx:key=\"{{item}}\" class=\"grid-list\">\r\n  <view class='grid-item'>\r\n  <text class='grid-item-text'>{{item}}</text>\r\n  </view>\r\n  </view>\r\n</view>\r\n\r\n//GridPage.wxss\r\nPage {\r\n  min-height: 100%;\r\n  background-color: #fff;\r\n}\r\n.grid-container {\r\n  margin-left: 4rpx;\r\n  margin-right: 4rpx;\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  flex-direction: row;\r\n}\r\n.grid-list {\r\n  width: 33.33%;\r\n}\r\n.grid-item {\r\n  margin: 2rpx;\r\n  background: #999;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.grid-item-text {\r\n  color: black;\r\n}这里的重点就是 grid-container 中的 flex-wrap 为 wrap ，方向是 row 了。然后他的每一个item宽度都是 33.33% 。需要注意的是一定是去设置外部的contanier而不是内部的list。层级布局在CSS中，需要使用层级布局，就是类似Android的FrameLayout效果，可以使用z-index，也可以使用一个绝对定位。比如，我们有一个需求是：下面是一个图片，上面是文字。//PositionPage.wxml\r\n<view class='root'>\r\n<image src='https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3756982450,995202616&fm=27&gp=0.jpg' class='image'></image>\r\n<text class='text'>我是权律二啊</text>\r\n</view>\r\n//PositionPage.wcss\r\n.root{\r\n  align-items: center;\r\n  display: flex;\r\n  flex-direction: column;\r\n  position: relative;\r\n}\r\n.image{\r\n  width: 300rpx;\r\n  height: 300rpx;\r\n}\r\n.text{\r\n  background-color: #999;\r\n  position: absolute;\r\n}主要是两点：父布局的 position 必须是 relative ，它本身 position 必须是 absolute。网络请求小程序的网络请求是使用wx.request()方法，但是该方法太臃肿，并没有使用Promise那样子简洁。幸运的是小程序支持Promise，所以我们可以把http封装一下，变成有条理。说到这里，大家做的时候需要注意去微信后台配置各种request域名，upload域名，downloadFIle域名。 下面封装的例子的数据返回格式都是json格式post请求方式发出的://真正发起请求\r\nfunction _request(url, param) {\r\n    if (isDebug) {\r\n        Log.i(\"http==> params->\" + JSON.stringify(param));\r\n        Log.i(\"http==> url->\" + url);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url: url,\r\n            data: param,\r\n            header: {\r\n                'content-type': 'application/json',\r\n                \"Accept\": \"application/json\"\r\n            },\r\n            method: \"POST\",\r\n            success: function (response) {\r\n                if (isDebug) {\r\n                    const jsonResponse = JSON.stringify(response);\r\n                    Log.i(\"http==> response->\" + jsonResponse);\r\n                }\r\n                const {data, statusCode, ok = false} = response;\r\n                //只有ok为true的是时候才返回成功，data不一定是包含数据的\r\n                if (statusCode === 200 && data && data.ok) {\r\n                    resolve(data, ok);\r\n                } else {\r\n                    if (statusCode != 404 && statusCode < 500 && statusCode > 300) {\r\n                        ToastUtil.showError();\r\n                    }\r\n                    reject(data);\r\n                }\r\n            },\r\n            fail: reject\r\n        });\r\n    });\r\n\r\n}使用：function getInfo(fid) {\r\n    const params = {};\r\n    params.token = user.token;\r\n    params.uid = user.uid;\r\n    return _request(\"INFO_URL\", params);\r\n}然后需要发起请求就调用该方法即可，处理Promise。上传图片到阿里云需要注意微信upload接口配置目前好像不可以直接配置阿里云的URL，需要阿里云先 跟我们的域名绑定，之后再去把设置到微信后台的upload接口中。可以参考博客： 小程序图片上传阿里OSS使用方法 ，获取签名阿里云Demo地址： JavaScript客户端签名直传 ，通过打log获得policy和signature（签名时间可以稍微设置久一点）之后，就开始封装upload方法了。 如下：/**\r\n    * 真实上传代码\r\n    */\r\n    function _upload(file, success, fail) {\r\n        const suffix = file.substring(file.lastIndexOf(\".\"));\r\n        //做一下md5处理\r\n        const fileName = hex_md5(file);\r\n        Log.i(\"fileName=\" + (fileName + suffix));\r\n        wx.uploadFile({\r\n            url: ALIYUNPHOTOADDRESS,\r\n            formData: {\r\n                \"OSSAccessKeyId\": \"你的阿里云accessKey\",\r\n                \"key\": DIR+ (fileName + suffix),\r\n                \"policy\": \"你的policy\",\r\n                \"success_action_status\": '200',\r\n                \"signature\": \"你的signature\"\r\n            },\r\n            filePath: file,\r\n            name: 'file',\r\n            success: function (res) {\r\n                const {statusCode} = res;\r\n                if (statusCode === 200) {\r\n                    console.log(JSON.stringify(res));\r\n                    success(\"\" + fileName + suffix);\r\n                } else {\r\n                    console.log(\"上传失败\");\r\n                    fail(res);\r\n                }\r\n            },\r\n            fail: function (e) {\r\n                fail(e);\r\n                console.log(\"上传失败\");\r\n                console.log(\"e=\" + JSON.stringify(e));\r\n            }, complete: function () {\r\n                console.log(\"上传过程结束\");\r\n            }\r\n        })\r\n    }\r\n\r\n}其中 url 是上传OOS的地址，key是需要上传的文件夹+上传之后的文件名。这里的fileName我们通过一个md5去计算得来，保证唯一性又没有什么特殊字符。md5的算法来自JS-MD5加密。我们可以顺带封装一个上传多张图片的方法,而且使用Promise返回：/**\r\n* files需要上传的文件，是一个数组,里面是文件的绝对路径\r\n*/\r\nfunction uploadFiles(files) {\r\n  if (!files || files.length <= 0) {\r\n    wx.showModal({\r\n      title: '图片错误',\r\n      content: '请重试',\r\n      showCancel: false,\r\n    });\r\n    return Promise.reject();\r\n  }\r\n  Log.i(\"开始上传\" + files);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    //上传成功的文件名称\r\n    let uploadPaths = [];\r\n    for (let i = 0; i < files.length; i++) {\r\n      _upload(files[i], (path) => {\r\n        //成功的文件名\r\n        uploadPaths[uploadPaths.length] = path;\r\n        if (uploadPaths.length >= files.length) {\r\n          //把url+name返回\r\n          resolve([ALIYUNPHOTOADDRESS + \"/\" +DIR, uploadPaths]);\r\n        }\r\n      }, () => {\r\n        //error\r\n        reject(res);\r\n      });\r\n    }\r\n\r\n  });Canvas使用由于需要使用Canvas画一棵树，所以还是在这里走了比较多的坑的。我的需求是Canvas全屏，除了画一个树之外还需要画别的一些独立Button。 首先，设置Canvas全屏和不可滑动，可以通过以下方式：<canvas  disable-scroll='true' style=\"width: {{width}}px; height: {{height}}px;background-color:#efeff4;flex:1;\" canvas-id=\"canvas\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\" bindtouchend=\"touchEnd\"></canvas>其中，在设置了disable-scroll设置为true，同时需要绑定三个touch事件，才能响应画布的触摸event。其中这里的width+height是通过wx.getSystemInfo()获得。其次，canvas没有类似View的catchtap事件，只有一些touch事件，详情可以看Canvas然后在微信小程序中Canvas是层级最高的，无法通过设置z-index去调，所以假如你的Canvas全屏，还需要一些其他的Button，那么只能通过最后canvas去draw了。在canvas中，假如通过moveTo+lineTo去画线，一般需要先调用canvas.beginPath()画完成之后，先调用canvas.stoke()，然后在调用canvas.closePath();c.beginPath();\r\n    c.setLineWidth(this.arrowPaint.width);\r\n    c.setStrokeStyle(this.arrowPaint.color);\r\n    c.setLineCap(\"square\");\r\n\r\n    c.moveTo(this.arrowStartPointF.x, this.arrowStartPointF.y);\r\n    c.lineTo(this.arrowCenterPointF.x, this.arrowCenterPointF.y);\r\n    c.moveTo(this.arrowCenterPointF.x, this.arrowCenterPointF.y);\r\n    c.lineTo(this.arrowEndPointF.x, this.arrowEndPointF.y);\r\n    c.stroke();\r\n    c.closePath();在连续画多种图片/线条的时候，不要连续多次调用draw(true)方法， 消耗性能，一般最后调用fill()/stoke()方法即可。比如//绘制点\r\n        c.beginPath();\r\n        let y = node.noteView.pointFrameCenter.y + Constant.FRAME_HEIGHT / 2 + Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT;\r\n\r\n        c.setFillStyle(Constant.LINE_COLOR_RED);\r\n        c.setLineWidth(Constant.LINE_WIDTH);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n\r\n        //\r\n        y += (Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n        //\r\n        //\r\n        y += (Constant.GAP_BETWEEN_DOT + Constant.RADIUS_DOT);\r\n        c.arc(node.noteView.pointFrameCenter.x, y, Constant.RADIUS_DOT, 0, 2 * Math.PI);\r\n\r\n        c.fill();\r\n        c.closePath();对于draw方法，建议只是调用draw()就好，不要调用draw(true)方法，draw(true)是在原画布之上再去画，不会清空旧画布，draw()会清空。一般，我们会在所有的image，rectangle，line,circle去fill/stoke完之后，再调用draw()方法，这样子就可以避免draw(true)多次，性能耗损。而且再次去reDraw的时候也不用先去清空画布。Canvas的跟随手势拖动//index.wxml\r\n  <canvas disable-scroll='true' style=\"width: {{width}}px; height: {{height}}px;background-color:#efeff4;\" canvas-id=\"canvas\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\" bindtouchend=\"touchEnd\"></canvas>\r\n//index.wcss\r\nPage {\r\n  overflow: hidden;\r\n  display: flex;\r\n}\r\n//index.js\r\nconst app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    width: 0,\r\n    height: 0,\r\n  },\r\n  onLoad: function (e) {\r\n    this.time = (new Date()).valueOf();\r\n    this.x = 0;\r\n    this.y = 0;\r\n    this.moveX = 0;\r\n    this.moveY = 0;\r\n\r\n    const that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        that.setData({ width: res.screenWidth, height: res.screenHeight })\r\n      },\r\n    })\r\n    const ctx = wx.createCanvasContext(\"canvas\", this)\r\n    this.canvas = ctx;\r\n  },\r\n  onReady: function () {\r\n    this.draw();\r\n  },\r\n  draw: function () {\r\n    this.canvas.fillRect(10, 10, 150, 100)\r\n    this.canvas.fill();\r\n    this.canvas.draw()\r\n  },\r\n  touchMove: function (e) {\r\n    console.log(\"touchMove\")\r\n    let xOffset = e.touches[0].x - this.x;\r\n    let yOffset = e.touches[0].y - this.y;\r\n    this.x = e.touches[0].x;\r\n    this.y = e.touches[0].y;\r\n    this.moveX = this.moveX + xOffset;\r\n    this.moveY = this.moveY + yOffset;\r\n    this.canvas.translate(this.moveX, this.moveY);\r\n    this.draw();\r\n  },\r\n  touchStart: function (e) {\r\n    this.x = e.touches[0].x;\r\n    this.y = e.touches[0].y;\r\n  },\r\n  touchEnd: function (e) {\r\n    console.log(\"touchEnd\")\r\n  }\r\n})其他的scale等方法类似。"}
{"title": "微信小程序开发--『狗蛋TV』 ", "author": "Rolan", "pub_time": "2018-5-17 00:08", "content": "狗蛋TV是基于微信小程序开发的一款App。gordanLee每天都会推荐一首歌、一篇文章、一段短视频，每天用十分钟的细碎时光，点燃内心的光明。目前分为音乐，短视频，影评三个模块。线上开源地址 https://github.com/lishuaixingNewBee/gordanTv 点个赞吧！小程序开发文档以下所有 API 均由产品公司自身提供，本人皆从网络获取。获取与共享之行为或有侵犯产品权益的嫌疑。若被告知需停止共享与使用，本人会及时删除此页面与整个项目。请您暸解相关情况，并遵守产品协议。为了方便大家学习和测试，我们提供了https的接口供大家使用，且用且珍惜。请在微信开发设置中加入request合法域名,或者在开发设置中勾选——不校验合法域名、web-view（业务域名）、TLS 版本以及 HTTPS 证书。感谢与支持-   狗蛋TVapi: https://api.gordantv.top\r\n    -   豆瓣api: https://api.douban.com\r\n    -   QQ音乐api: https://y.qq.com项目介绍狗蛋TV是基于微信小程序+ES6进行开发，能同时运行在Android、iOS环境下。涵盖了音乐、短视频、影评三个版块。开屏引导图调用微信wx.onAccelerometerChange重力感应设备API,实现水波荡漾。调用wx.getUserInfo获取用户头像。工具类用Promise封装wx.request(),简化代码结构:const $get = (url, data) => {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url,\r\n      data,\r\n      header: { 'Content-Type': 'json' },\r\n      success: resolve,\r\n      fail: reject\r\n    })\r\n  })\r\n}电影评分实现const convertToStarsArray = (average) => {\r\n  const LENGTH = 5;\r\n  const CLS_ON = 'on'; // 全星\r\n  const CLS_HALF = 'half'; // 半星\r\n  const CLS_OFF = 'off'; // 无星\r\n  let result = [];\r\n  let score = Math.round(average) / 2;\r\n  let hasDecimal = score % 1 !== 0\r\n  let integer = Math.floor(score)\r\n  for (let i = 0; i < integer; i++) {\r\n    result.push(CLS_ON)\r\n  }\r\n  if (hasDecimal) {\r\n    result.push(CLS_HALF)\r\n  }\r\n  while (result.length < LENGTH) {\r\n    result.push(CLS_OFF)\r\n  }\r\n  return result;\r\n}小程序内部组件实现上拉刷新，下拉加载方法一：scroll-view 组件\r\n    方法二：onPullDownRefresh和onReachBottom方法实现小程序下拉加载和上拉刷新阅读模块微信小程序使用wxParse解析html项目中遇到在微信小程序里需要显示音乐文章的内容，文章内容是通过接口读取的服\r\n务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，\r\n那我们需要显示html内容的时候，就可以通过wxParse来实现。项目安装\r\n    git clone git@github.com:lishuaixingNewBee/gordanTv.git\r\n目录结构\r\n\r\n|--- utils & Public Function              通用函数\r\n|--- components & components Public View  components和template模板\r\n|--- images & Img Resources               图片资源\r\n|--- pages & View Dir                     页面"}
{"title": "微信小程序开发BUG经验总结 ", "author": "Rolan", "pub_time": "2018-6-4 00:38", "content": "小程序开发越来越热，开发中遇到各种各样的bug，在此总结了一些比较容易掉进去的坑分享给大家。1. new Date跨平台兼容性问题在Andriod使用 new Date(“2018-05-30 00:00:00”) 木有问题，但是在ios下面识别不出来。因为IOS下面不能识别这种格式，需要用 2018/05/30 00:00:00 格式。可以使用正则表达式对做字符串替换，将短横替换为斜杠。 var iosDate= date.replace(/-/g, '/'); 。2. wx.getUserInfo()接口更改问题微信小程序最近被吐槽最多的一个更改，就是用户使用wx.getUserInfo（开发和体验版）时不会弹出授权，正式版不受影响。现在授权方式是需要引导用户点击一个授权按钮，然后再弹出授权。解法很长，请参考:解法1： 微信小程序不支持wx.getUserInfo授权的解决方法解法2： getUserInfo兼容解决方案3. 只有在调试模式下，才能发送数据到自己的正式服务器其实，只要注意配置合法域名，这个问题就解决了。有的时候，因为一上来就开发，忘记掉去配置域名。后来发现数据没法出去，可能半天没想来忘记配置了！4. 无法获取UnionID的问题login获取UID必须满足两个条件： 1、把小程序和公众号都绑定在开放平台； 2、用户必须已经关注公众号。用wx.getUserInfo获取满足一个条件：把小程序和公众号都绑定在开放平台；5. wx.getSystemInfoSync获取windowHeight不准确主要原因在于获取是时机，wx.getSystemInfoSync是在页面初始化的时候就计算了，基本上可以理解为是屏幕高度。所以，最好的方法是使用异步接口，并且在onReady函数中调用。onReady() {\r\n  wx.getSystemInfo({\r\n    success({windowHeight}) {\r\n      // todo\r\n    }\r\n  });\r\n}6. 图片本地资源名称，尽量使用小写命名在解决iPhone X适配时，底部多余部分使用图片时<image class='iphonexImg' src=\"/imgs/iphoneBGT.png\" mode=\"aspectFill\">image>路径是 src='imgs/iphoneBGT.png'发现在pc IDE上面可以显示出来，但是真机调试时，图片找不到，然后将图片名称改为iphonex.png真机调试就可以了<image class='iphonexImg' src=\"/imgs/iphonex.png\" mode=\"aspectFill\">image>写在最后：代码总是有各种bug，像上面列举的问题还是在开发中就可以发现。而代码上线以后呢，测试也不能保证100%没有问题。在这里，推荐Fundebug的 微信小程序bug监控服务 给各位老铁！关于Fundebug2017年初，小程序还刚上线，Fundebug就支持小程序错误监控了。做为最早的小程序错误监控服务的拓荒者，累计为数千个小程序提供免费服务，累计处理数千万小程序错误。"}
{"title": "微信小程序开发之从相册获取图片 使用相机拍照 本地图片上传 ... ... ", "author": "Rolan", "pub_time": "2018-6-19 00:26", "content": "1.index.wxml1 <!--index.wxml-->  2 <button style=\"margin:30rpx;\" bindtap=\"chooseimage\">获取图片</button>  3 <image src=\"{{tempFilePaths }}\" mode=\"aspecFill\" style=\"width: 100%; height: 450rpx\"/>  2.index.js 1 //index.js   2 //获取应用实例   3 var app = getApp()   4 Page({   5   data: {   6     tempFilePaths: ''   7   },   8   onLoad: function () {   9   },  10   chooseimage: function () {  11     var _this = this;  12     wx.chooseImage({  13       count: 1, // 默认9  14       sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有  15       sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有  16       success: function (res) {  17         // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片  18         _this.setData({  19           tempFilePaths:res.tempFilePaths  20         })  21       }  22     })  23   }  24 })  这里说说sourcetype.默认是从相册获取和使用相机拍照,跟微信现在选择图片的界面一样,第一格是拍照,后面的是相册照片.这里注意:返回的是图片在本地的路径.如果需要将图片上传到服务器,需要用到另一个API.示例代码: 1 wx.chooseImage({   2   success: function(res) {   3     var tempFilePaths = res.tempFilePaths   4     wx.uploadFile({   5       url: 'http://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址   6       filePath: tempFilePaths[0],   7       name: 'file',   8       formData:{   9         'user': 'test'  10       },  11       success: function(res){  12         var data = res.data  13         //do something  14       }  15     })  16   }  17 })"}
{"title": "【腾讯游戏人生】微信小程序开发总结 ", "author": "Rolan", "pub_time": "2018-6-27 00:23", "content": "目前【腾讯游戏人生】小程序已经发布上线，大家可以扫小程序码进行体验。接下来主要介绍在开发该款小程序过程中的一些思考和积累。一、基础普及1.1简介微信小程序是微信公众平台推出除服务号、订阅号、企业号外的第四种微信内应用类型，它是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的仿原生app的交互使用体验和实用功能。我们可以方便的在微信公众平台进行小程序的注册和提交资料，与微信公众号的注册流程较为一致。对于公司内部的小程序也可以在公司内部平台进行快速注册和审核，地址为http://mmbiz.oa.com/inneraccount?action=index，在此不具体赘述。1.2配置用户配置：小程序管理平台提供用户管理功能，支持添加1个管理员，根据帐号类型和是否认证分别支持配置不同数目的开发者和体验者帐号权限，这些配置在小程序开发和内测阶段十分有用，即是一个官方的白名单配置功能。开发配置：与微信公众号其他帐号开发接入配置类似，需要分别设置开发者ID和密钥、服务器域名配置、开发消息接入地址等信息，可参考小程序开发文档逐一设置，对于有开发公众号经验的同学来说也比较快速入手，只是需要注意这里的域名接入都必须要是https的服务域名地址。二、开发注意2.1页面模型小程序包含一个描述整体程序的 app 和多个描述各自页面的 page组成，可以看做是一系列页面的组合集成，由一个全局app对象调度运行。页面模型是小程序里的一个很重要的概念，从小程序配置文件app.json中也可以看到(如下所示)，在app.json中注册的页面地址才可以被调用和打开展示。小程序的展示页面主要分为tabbar页和常规页两种，而只有tabbar页才会有底部tabbar显示，两类页面对应的跳转方式api也不同：对于tabbar页地址(例 page/xxx/xxx)，调用wx.switchTab(OBJECT)进行跳转；对于常规页地址(例 page/xxx/x1)，调用wx.navigateTo(OBJECT)或wx.redirectTo(OBJECT)进行跳转{\r\n  \"pages\": [\r\n    \"page/xxx/x1\",\r\n    \"page/yyy/y1\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"test\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"page/xxx/xxx\",\r\n      \"iconPath\": \"image/xxx.png\",\r\n      \"text\": \"tab1\"\r\n    }, {\r\n      \"pagePath\": \"page/yyy/yyy\",\r\n      \"iconPath\": \"image/yyy.png\",\r\n      \"text\": \"tab2\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"uploadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n} 对于一个具体的页面模型，都有其内部独立的逻辑和数据作用域。主要包括四个组成文件，且必须要有相同的路径目录和文件名，例如：首页对应/page/index/目录下的index.js、index.wxml、index.wxss、index.json文件。页面的初始化、渲染、交互等逻辑都可以通过页面js进行事件监听和函数调用进行响应和处理，类似做web前端开发一样，只是需要特别注意该js开发与web前端js开发的部分不同之处：页面逻辑运行在Jscore中，非webview，无window、body、document等dom对象结构；无页面cookie，无法设置网络请求header的refer；不支持类似jquery、zepto等对象拾取插件和操作方式，视图更新通过数据绑定方式实现；页面展示结构主要由官方原生组件拼装展示，并通过对应支持的有限的事件函数进行响应控制，扩展化较低；页面数据的改变通过调用Page.setData函数回显页面组件展示，页面组件的动作事件值；e.detail.value可以传递给事件响应函数重设页面数据，以此达到页面数据和组件的联动绑定2.2生命周期小程序的运行和各页面的展示都有其特定的生命周期，并通过一系列的声明周期函数进行调度控制。例如app全局实例的onLaunch、onShow、onHide等监听函数来响应小程序初始化和显影时的控制逻辑。而对于page页面则拥有更为丰富的监听调控函数，实现页面生命周期中更多情况的控制处理。下图说明了小程序page页面实例的生命周期运作：而针对小程序内部的多个页面之间的切换展示管理，则由小程序框架路由和页面栈控制托管，并通过路由标签或导航方式api函数进行页面切换。需要注意的是页面初始化第一次onLoad后如果只是onHide在后台不展示而并未onUnload销毁，下次再切回该页面展示时，不会再触发onLoad监听，而是触发onShow监听；onShow在页面的初始化或每次展示时都会触发，因此这里有个小技巧，部分需要实时更新展示到页面的数据可在onShow中进行获取处理。三、数据处理3.1数据请求小程序里的网络请求主要由wx.request(OBJECT)、wx.uploadFile(OBJECT)等api访问小程序配置的https域名url接口实现。前者类似于ajax请求，后者通常用来上传图片文件等。这里请求API有些坑需要注意：请求不支持设置header的refer；请求url不允许带自定义端口，只能是默认80端口；请求content-type默认为'application/json'，如需用POST请求则需改为'application/x-www-form-urlencoded'或'multipart/form-data'，否则后台请求里得不到post数据；后台接收请求php里最好用json_decode（file_get_contents(\"php://input\")）方式获取完整的post数据，否则如果传递较为复杂的多层post数据结构体，直接用$_POST等可能导致获取数据格式异常或失败小程序里的数据请求操作最好都需要进行登录态安全校验，我们在这里仿造之前做H5项目的微信授权校验方式，把调用微信登录和授权后获得的openid等数据进行加密获取一个ticket票据，并设有过期时间，小程序的每个数据请求则需要附加携带openid和该ticket参数在后台php里进行校验，成功则正常进行后续请求和返回数据，失败则告知小程序客户端重新登录和授权后再请求数据。校验的核心算法也较为简单，就是判断在ticket有效期时间内是否满足如下等式：sha1(APPID@openid@TOKEN)  ==  ticket而登录和授权后初始的ticket生成也即用的该算法左式生成，并返回小程序本地缓存记录，下次请求可从缓存取出直接应用。最后对小程序里的所有数据请求进行了处理，封装了GET/POST请求的header设置、登录态参数的附加和过期处理、请求loading效果的显隐控制等逻辑，并设置在app全局对象的暴露方法httpRequest中，方便在各子页面调用处理。由于我们的小程序需要根据用户身份展现不同状态的tabbar首页，因此需要把用户身份信息的请求前置，这里设计了一个loading过渡页面，且刚好在这个页面进行了微信登录和授权，并得到登录态参数初始化，然后请求了用户的身份后设置到app全局数据，并在tabbar首页进行对应判断和展示。3.2页面通信我们的小程序里有需要商家注册和创建擂台的功能页面，需要填写的信息和层级较多，不足以一屏展示和填写，因此需要支持数据在跨页面间的传递和调用的通信能力，且对数据进行完整、有效和安全的管理，并实时响应页面更新展示。基于小程序本身提供的api和特点，也查阅了一些资料，主要得到如下几种思路和方法：我们考虑到表单数据较多，且产品需求表单需要本地草稿的功能，下次再打开可显示上次填写数据，无需重新再次填写，因此最终结合了缓存和页面路由栈的功能进行实现。在表单主页面A利用localStorage缓存托管表单全体数据formData，并在子页面B用页面栈getCurrentPages获取和操作主页面A的表单某块子数据formData.subData，子页面B的修改操作通过A.setData实时传递和通知主页面A的刷新展示，主页面A在onUnload中响应对localstoreage的修改保存，便于下次加载读取。四、代码维护4.1公用配置小程序代码中涉及的较多数据、参数、接口、文案等自定义信息，可做成统一本地化配置，放入app实例的全局数据中公用，便于各子页面获取处理，同时结合小程序loading初始化时进行远程请求更新配置。这样的好处是，可以兼容配置信息更新与否情况下的配置统一管理。当需要配置更新时，能从远程拉取替换，而不需要修改小程序的代码文件，重新再走代码发布及等待审核的流程。4.2传图组件小程序中注册商家资料和创建擂台时都涉及到了图片的上传处理，用到了小程序官方的传图样式组件和API，同时需要调用统一的后台上传图片生成URL的接口。因此这里有必要可以进行组件模块化封装的代码优化，便于在多个page页面内引入调用。picloader.wxml<template name=\"picloader\">\r\n    <view class=\"weui-cells weui-cells_after-title\">\r\n        <view class=\"weui-cell\">\r\n            <view class=\"weui-cell__bd\">\r\n                <view class=\"weui-uploader\">\r\n                    <view class=\"weui-uploader__hd\">\r\n                        <view class=\"weui-uploader__title\">{{title}}</view>\r\n                    </view>\r\n                    <view class=\"weui-uploader__bd\">\r\n                        <view class=\"weui-uploader__files\">\r\n                            <block wx:if=\"{{picture}}\">\r\n                                <view class=\"weui-uploader__file\" bindtap=\"previewImage\" data-obj=\"{{name}}\">\r\n                                    <image class=\"weui-uploader__img\" src=\"{{picture}}\" mode=\"aspectFill\" />\r\n                                </view>\r\n                            </block>\r\n                            <input id=\"{{name}}\" name=\"{{name}}\" hidden=\"{{true}}\" value=\"{{picture}}\"/>\r\n                        </view>\r\n                        <view class=\"weui-uploader__input-box\">\r\n                            <view class=\"weui-uploader__input\" bindtap=\"chooseImage\" data-obj=\"{{name}}\"></view>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"weui-cell__ft\"><icon type=\"{{validate}}\"/></view>\r\n        </view>\r\n    </view>\r\n</template>picloader.jsconst app = getApp();\r\n\r\nfunction init(pageDelegate) {\r\n  //1.初始化图片上传种子HASH值\r\n  app.httpRequest({\r\n      url:app.Utils.getRequestUrl(\"getUploadHash\"),\r\n      success: function( res ) {\r\n          if(res.r== \"0\"){\r\n              pageDelegate.setData({\r\n                  _hash:res._hash\r\n              });\r\n          }\r\n      },\r\n  },false);\r\n\r\n  //2.绑定选择图片事件\r\n  pageDelegate.chooseImage = function (e) {\r\n    var that 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nddghjikle\r\n\r\n\r\n\r\nwW46\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              浅析微信小程序 App() 和 Page() 函数的内部实现 \n              微信小程序-封装请求（GET、POST） \n            \n             \n            \n                  原作者: 一时两无 \n                  来自: 腾讯云 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 小程序开发技巧总结\n                                    \n                  • 微信小程序：漫画小程序项目总结\n                                    \n                  • 微信小程序-测试游戏生成六边多边形\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    1 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         Rolan\r\n                \r\n       \r\n       2018-6-27 10:03\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    picloader.js\r\n\r\nconst app = getApp();\r\n\r\nfunction init(pageDelegate) {\r\n  //1.初始化图片上传种子HASH值\r\n  app.httpRequest({\r\n      url:app.Utils.getRequestUrl(&quot;getUploadHash&quot;),\r\n      success: function( res ) {\r\n          if(res.r== &quot;0&quot;){\r\n              pageDelegate.setData({\r\n                  _hash:res._hash\r\n              });\r\n          }\r\n      },\r\n  },false);\r\n\r\n  //2.绑定选择图片事件\r\n  pageDelegate.chooseImage = function (e) {\r\n    var that = this;\r\n    var uploadUrl = app.Config.uploadBase;\r\n    var obj = e.currentTarget.dataset.obj;//修改对象名\r\n    if (e.currentTarget.dataset.ratio) {//尺寸比例限制\r\n      uploadUrl += &quot;?size_ratio=&quot; + e.currentTarget.dataset.ratio;\r\n    }\r\n\r\n    wx.chooseImage({\r\n        sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n        sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n        count:1,\r\n        success: function (res0) {\r\n            // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n            app.uploadRequest({\r\n                url:uploadUrl,\r\n                filePath: res0.tempFilePaths[0],\r\n                data:{\r\n                    _hash:that.data._hash\r\n                },\r\n                success:function(res){\r\n                    var picurl = res.url || &quot;&quot;;\r\n                    var tmpData = {};\r\n                    tmpData[&quot;formData.&quot; + obj] = picurl;\r\n                    that.setData(tmpData);\r\n                    app.Utils.checkValid(obj, picurl,that);\r\n                    if (res.r != &quot;0&quot; && res.msg){\r\n                      wx.showModal({\r\n                        title: '图片上传失败',\r\n                        content: res.msg,\r\n                        showCancel: false,\r\n                        success: function (res) {\r\n                        }\r\n                      });\r\n                    }\r\n                }\r\n            })\r\n        }\r\n    })\r\n  }\r\n\r\n  //3.绑定预览图片事件\r\n  pageDelegate.previewImage = function (e) {\r\n    var obj = e.currentTarget.dataset.obj;//修改对象名\r\n    var pic = this.data.formData[obj] || &quot;&quot;;\r\n    if(pic == &quot;&quot;){\r\n        return false;\r\n    }\r\n    \r\n    wx.previewImage({\r\n        current: e.currentTarget.id,\r\n        urls: [pic] // 需要预览的图片http链接\r\n    });\r\n  }\r\n}\r\n\r\n//模块化\r\nmodule.exports = {\r\n  init: init\r\n}\r\n 使用示例wxml中：\r\n<import src=&quot;/page/common/picloader.wxml&quot;/>\r\n<template is=&quot;picloader&quot; data=&quot;{{title: '奖励图片上传',picture:formData.award_pic,validate:validate.award_pic,name:'award_pic'}}&quot;/>\r\n使用示例js中：\r\nconst app = getApp();\r\nvar picloader = require('/utils/picloader.js');\r\n\r\nPage({\r\n  data:{\r\n      ...\r\n  },\r\n  onLoad:function(options){\r\n      // 页面初始化 options为页面跳转所带来的参数\r\n\r\n      //注册图片上传组件\r\n      picloader.init(this);\r\n  },\r\n  ...\r\n})\r\n\r\n4.3分片模版\r\n\r\n小程序tabbar首页的需求是根据不同的用户身份展现不同状态的首页，有未入驻、待审核、审核通过、审核被拒四种状态，而都需要对应到同一个tabbar首页url。因此这里需要把四种状态的页面片段部分分别做成子模版wxml的形式，通过小程序的条件渲染（wx:if）机制根据用户身份情况按条件调用对应子模版进行展示。\r\n\r\n同时小程序较多页面都有共同的头部（banner图）和尾部（联系客服）等片段展示，因此这里也考虑把其做成对应的公用head和foot子模版wxml，便于多页面include引用。\r\n\r\n<view class=&quot;page&quot;>\r\n    <include src=&quot;/page/common/head.wxml&quot;/>\r\n    <view class=&quot;weui-msg&quot;>\r\n        <include wx:if=&quot;{{status == 1}}&quot; src=&quot;subpage/wait.wxml&quot;/>\r\n        <include wx:elif=&quot;{{status == 2}}&quot; src=&quot;subpage/success.wxml&quot;/>\r\n        <include wx:elif=&quot;{{status == 3}}&quot; src=&quot;subpage/fail.wxml&quot;/>\r\n        <include wx:else src=&quot;subpage/default.wxml&quot;/>\r\n    </view>\r\n</view>\r\n<include src=&quot;/page/common/foot.wxml&quot;/>\r\n\r\n五、总结体会\r\n\r\n【腾讯游戏人生】微信小程序开发已经结束，亟待补充产品条款以及发布审核上线。在整个摸索和开发过程中，碰到了许多与web开发不同的别扭之处，也填过不少坑，包括参与小程序实现的设计、重构和前端开发都是一个新的尝试与体验。也对此有一些思考和总结，具体如下归纳。目前感觉小程序比较适用于一些旨在更快速和有效推广自己轻量功能的小应用模式，不适合较大较重逻辑和功能的开发应用。但相信随着微信官方对小程序支持力度的不断增加，小程序的功能和推广也将得到进一步扩大，接入和开发成本的同步降低，也会受到越来越多的开发者欢迎和喜爱。\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSDwOyAj', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序解决方案 Westore - 组件、纯组件、2018-10-10小程序第三方框架对比 ( wepy / mpvue / ta2018-10-19微信小程序之：云开发初体验--致我的第一个2018-10-19微信小程序跳H5页面2018-10-19node.js 抓取网页内容（针对微信小程序云开2018-10-22小程序即时通讯demo2018-10-109块钱部署一个小程序2018-10-17小程序源码反编译实战笔记2018-10-12微信小程序图片预加载组件 wxapp-img-loade2018-10-18\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n大学签到2018-10-27背单词小程序，小鸡单词，仿墨墨背单词2018-10-22微信小程序翻译demo12018-10-21开源分享，记账小程序demo2018-10-17微信小程序Demo:水浒卡2018-10-17云开发demo:猫叫助手2018-10-15自定义日期时间选择器2018-10-09小程序数据怎么获取2018-09-28商城类小程序注册相关问题2018-09-20\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1541431628|341bf916e7325e2c1455e61fc761578c|2';"}
{"title": "微信小程序开发框架从入门到放弃 ", "author": "Rolan", "pub_time": "2018-7-23 00:40", "content": "用框架是不可能用框架的，这辈子都不可能用框架。微信小程序上手成本低，开发成本低，流量红利，推广成本低等等，很多公司的创业项目都会首选小程序来试水，小程序开发太火爆了,苦逼了前端工程师，又得学习新技术...学习让我快乐半年时间，我已经开发了四个小程序，其中三个微信小程序，一个支付宝小程序。原生开发过，框架也用过。到底最优雅的开发模式是什么呢，聊聊，聊聊。技术方案目前开发微信小程序时，可选的技术方案大概有若干种，分别是：微信小程序原生开发使用wepy框架使用mpvue框架使用taro框架其他框架使用框架来开发，总结起来就干了一件事——加糖，但这糖好不好呢，不好说。框架开发的初(li)衷(xiang)快速迭代减少开发成本跨平台共享提升开发体验框架开发的挑(xian)战(shi)必须同时熟悉微信小程序文档和第三方框架文档，给工程师提出了更大的挑战框架的不完美，只是阉割版或者修改版的前端框架，并没有100%支持框架自身特性框架构建与微信小程序之上，反而导致部分原生支持的特性作废，比如原生组件，模块化等框架生态不健全，文档及相关资源匮乏微信小程序自身处于快速迭代的状态，特性并不稳定，不像web一样有统一的标准理想很美好，现实很残酷wepy框架来说，组件化的支持不成熟，在实际的开发过程中，如果组件嵌套超过两层，面对某些特殊业务场景，翻车几率很高。组件的列表渲染，不支持在 repeat 的组件中去使用 props, computed, watch 等等特性。mpvue框架是基于Vue.js的核心，属于修改版的vue框架，用起来和web端的vue也有些差异。美团小程序框架--mpvue入坑指南我的想法使用第三方框架开发，可以享受框架带来的开发便利，但对于小程序新增的诸多特性和功能，比如WXS模块、自定义组件和插件等，受制于第三方框架，无法使用。而原生小程序的开发模式，又过于简陋，就样式来说，写惯了less，stylus和sass的同学一定无法忍受wxss的这种写法，基于此，决定使用gulp自动化工具来构建一套微信小程序开发的基础模板，在完全保留微信小程序功能和特性的基础上，又可以的使用less来写样式，同时加入图片压缩，命令行快速创建模板等特性，如此开发，快哉，快哉！wx-miniprogram-boilerplate后续会再加入其它工具，持续更新，欢迎各位提意见。"}
{"title": "基于后端云微信小程序开发 ", "author": "Rolan", "pub_time": "2018-7-25 00:29", "content": "人的一生90%的时间都在做着无聊的事情，社会的发展使得我们的闲暇时间越来越多，我们把除了工作的其他时间放在各种娱乐活动上。程序员有点特殊，他们把敲代码看成娱乐活动的一部分，以此打发时间的不占少数。这不最近无聊搞了一个口袋吉他小程序，使用bmob后端云提供数据存储服务，除吉他谱图片，其他图片存储在七牛。关于bmob小程序开发文档请戳这里，文档详细简练，主要是缩短了开发周期，不过对于复杂的项目，还是推荐使用自己服务器提供数据服务。使用微信扫描二维码预览源码地址： github.com/alex1504/wx…下面分点分享下小程序的开发过程中的关键点及感受，说明：小程序标签统称组件，Html标签统称元素。部分内容会与vuejs及jQuery作对比使用iconfont字体图标新建项目并添加图标在app.wxss中以unicode方式引入@font-face {\r\n  font-family: 'iconfont';  /* project id 431644 */\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot');\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot?#iefix') format('embedded-opentype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.woff') format('woff'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.ttf') format('truetype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.svg#iconfont') format('svg');\r\n}\r\n复制代码定义通用icon样式，定义伪元素.icon{\r\n  display: inline-block;\r\n  font-family: 'iconfont';\r\n}\r\n.icon-home::before{\r\n  content: \"\\e600\";\r\n}\r\n复制代码使用<view class=\"icon icon-home\"</view>\r\n复制代码小程序事件绑定及处理器小程序并没有类似vuejs的v-model进行双向绑定，使用bindinput类似jQuery监听input事件在事件处理器中更新数据，通过event对象e.data.value即可获得input的值。// bindconfirm监听键盘回车事件，focus属性聚焦渲染组件时会自动弹出手机软键盘\r\n<input type='text' placeholder='歌曲名 / 歌手' bindinput='bindSearchInput' bindconfirm='onSearch' focus></input>\r\n复制代码bindSearchInput(e) {\r\n  this.setData({\r\n    searchTxt: e.detail.value\r\n  })\r\n}\r\n复制代码小程序中的事件处理器并不能像vue一样传入参数，因为事件处理器只有一个默认的参数event对象，在for循环的组件中如果要想获取元素绑定的id，可以通过和jQuery相同的方式绑定data属性。<!-- 轮播图 -->\r\n<swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n  <block wx:for=\"{{banner_list}}\" wx:key=\"{{index}}\">\r\n    <swiper-item bindtap=\"navigateToDetail\"  data-id=\"{{item.href}}\">\r\n      <image src=\"{{item.image}}\" class=\"slide-image\" mode=\"widthFix\"></image>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>\r\n复制代码获取id：//事件处理函数\r\nnavigateToDetail: function (e) {\r\n  const id = e.currentTarget.dataset.id;\r\n}\r\n复制代码阻止事件冒泡bindtap、bindlongtap、bindtouchstart、bindtouchmove、bindtouchend、bindtouchcancle\r\n复制代码对应阻止冒泡事件将bind用catch替代setData小程序的视图更新需要调用setData修改绑定数据，直接对数据进行修改是不会触发视图层更新的。setData接受一个对象，为需要添加或修改的属性。属性名有点特殊，[]中的值会被识别为变量，因此如果要对对象数组中的某个属性进行修改，只能预先拼接好属性名。 错误做法：// 视图不更新\r\nthis.data.searchSongs[index].love_flag': 2\r\n// SyntaxError: unknown: Unexpected token\r\nthis.setData({\r\n  'searchSongs[' + index + '].love_flag': 2\r\n})\r\n复制代码正确做法：setSongFlag(e) {\r\n// 注意setData属性名[]中的非整数值会被识别为变量\r\nlet key = 'searchSongs[' + index + '].love_flag'\r\nthis.setData({\r\n  [key]: 2\r\n})\r\n复制代码关于image组件小程序wxss的background-image及image组件都不支持本地url 在H5的开发中，通常我们会将页面一些不需要根据容器大小来选择显示方式的图片使用img标签，需要一些特殊显示方式的使用background。但小程序只需要image组件便可。它提供的mode属性和背景定义图片及img元素控制图片显示方式对比mode属性background-sizehtml img元素scaleToFill100%,100%(默认)width:100%;height:100%aspectFitcontainjs实现aspectFillcoverjs实现widthFix100%, autowidth: 100%;其他的top、bottom、right、left等不缩放图片调整位置的属性与background-position作用相同，img元素则只能通过定位控制。小程序API异步方案如果没有强迫症，小程序API使用默认回调的方式即可；另外由于小程序只支持es6，不支持async及await，也可以将API封装成promise的方式。function promisify(fn) {\r\n  return function (obj = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      obj.success = function (res) {\r\n        resolve(res)\r\n      }\r\n\r\n      obj.fail = function (res) {\r\n        reject(res)\r\n      }\r\n\r\n      fn(obj)//执行函数，obj为传入函数的参数\r\n    })\r\n  }\r\n}\r\nmodule.exports = {\r\n    promisify: promisify\r\n}\r\n复制代码使用：const promisify = require('./promisify.js')\r\nconst request = promisify(wx.request);\r\n\r\nrequest({\r\n    url: 'some URL'\r\n    method: 'GET',\r\n}).then(res => {   \r\n    console.log(res)                 \r\n}\r\n复制代码小程序问题调试器没有css快捷提示功能和颜色面板，影响布局及颜色调整效率（随性派）无法引入第三方js库内置组件单调，没有考虑字体数量比较多时的自适应情况不支持跳转外部链接背景图片或者image组件不能用本地图片关于小程序审发布或更新小程序上线需要经过审核、发布两个过程。 审核通过后有全量更新、或者分阶段发布，小程序才会更新，首次发布没有选项。全量发布：即时向全量微信用户发布新版小程序。 分阶段发布：新版小程序将在15天内以开发者自定义比例，向微信用户发布更新 详情见知乎： 发布小程序时选择全量发布和分阶段发布是什么意思？不得不说小程序审核速度是非常快的，即便是个人申请（相比以企业账号申请会有应用服务类型限制），通常小程序没有涉及政策不允许的内容或者超过小程序允许的应用服务类型，都是可以顺利通过，初次体验，即便在国庆期间，也是有工作团队进行审核，审核时间通常在几小时内。总结在开发这个小程序时，微信小程序只支持页面级开发，如今小程序已支持组件开发和插件开发。组件的结构和页面并无区别，自定义组件可以引入其他的组件，具体的开发步骤可以参考这边文章 【微信小程序】自定义组件小程序的兴起使得前端开发又多了一个工作任务，但这也使得前端程序员的成就感越来越强，当然没有经历过浏览器刀耕火种年代的工程师难以体会这种辛酸，但也没必要，只要跟上时代的潮流和注重自身的基础建设便已足够了，前端路途艰辛，我在路上与你共勉。"}
{"title": "微信小程序开发之从“跳伞”到“吃鸡” ", "author": "Rolan", "pub_time": "2018-7-26 00:28", "content": "写在前边微信小程序随着官方开放越多越多的接口，也是变的越来越火了，越来越多的企业已经开始布局小程序生态。所以，对于我们开发者来说，掌握小程序开发显得分外重要。如果点亮了该技能，那么离升职加薪赢取白富美的日子就又近了一步啦！关于我笔者算是一个野生的程序猿吧，没有什么大厂经验，搞开发就是一个字，干！从不来虚的。因此，随性的性格造就了我全栈（一窍不通）的本事，做项目那就是一把抓，前后端全包，什么前后端撕逼的问题统统没有了，哈哈哈（想想心里还有点小激动）。不过本文笔者只重点分享小程序开发相关的东西，想了解后端的话，可以坐等我下一次的分享哈哈哈（可能会遥遥无期）。准备工作话不多说，进入正题。现在开始分享我是怎么开发完一款小程序的。小程序的官方文档其实写的是很详细很清晰的，相比微信公众号的开发文档来说真的是非常非常的良心，所以开发前浏览一遍开发文档非常关键。下边我分享一下其他准备工作。1. 开发工具工欲善其事，必先利其器，首选的就是把开发环境给弄好咯，我推荐如下：开发工具官方微信开发者工具visio studio code调试工具官方微信开发者工具当然开发工具什么的只要自己习惯就好，我的推荐只是参考。笔者最后习惯是直接在官方的开发者工具上编辑加调试。2. 小程序配置这块的内容官方文档都有详细的教程，我就不多补充啦。总体来说就是需要去申请一个开发者账号，然后配置小程序的基本信息，比较值得重点说的就是小程序api的配置，官方要求必须是https。说到这里，如果读者你的api接口已经了https可以跳过了，如果不是，然后你也像笔者一样是全栈开发，那么笔者将告诉你如何快速让接口踏上https的航班。是的，没错， 就是它！Certbot在官网上选好http服务器和linux系统后，按照命令一个一个敲，就ok了，简直不要太简单。哈哈哈，至于想深入了解这个东东的话，可以去了解下Let's Encrypt开发总算可以正式的开始撸功能了！因为考虑到现在程序猿找对象是真的太难了，所以笔者撸的小程序是一个脱单交友的小程序（单身汪的福音哦），小程序页面也不多，核心就是让用户填写个人信息然后展示出来。是的，就是这么简单！授权登录小程序的授权登录其实可以看作是两件事情，授权和登录，这两者是可以单独分开处理的（个人观点，允许反驳）。授权对于授权，其实官方已经有讲到，就是换成微信内的授权询问，就是如下这个东西。这个微信授权的询问弹窗之前的版本中只要调用获取用户信息的api，是会自动弹出的，现在小程序做了调整需要自行通过按钮触发，所以这个很蛋疼。那么需要怎么去设计呢，这里也有两个方案，一个是做个单独的页面，另一个方案是做弹窗。个人建议是选方案一，因为这样可以把授权逻辑从页面逻辑里独立出来，方便所有页面渲染前调用。具体coding如下：在app.js中，判断是否已经授权，如果未授权则跳转到授权页面App({\r\n  onLaunch: function () {\r\n    ...\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },在'pages/auth/index.wxml'页面中，使用button做授权按钮<button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">微信账号授权登录</button>'pages/auth/index.js'中定义绑定的回调方法，重新跳转回上一页Page({\r\n  ...\r\n  // 点击授权后跳回首页\r\n  bindGetUserInfo (e) {\r\n    wx.reLaunch({ url: '../index/index' })\r\n    // 用户已经同意小程序使用获取用户信息功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n  }\r\n})\r\n这样，一个授权逻辑就完成了。登录登录的目录其实是和后端交互，需要在服务器端存储当前用户的标识，以便用户下一次登录时服务器知道是谁登录了。做过微信公众号开发的朋友应该都知道，能承担这个作用的角色就是open_id了，所以要实现登录的话，其实就是需要获取当前用户的open_id，官方文档中是这么介绍的：1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。所以完成登录的前提就是需要后端提供一个接口，咱们把code传给后端就行了，剩下的工作就是后端去完成啦App({\r\n  onLaunch: function () {\r\n    // 授权判断\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },\r\n  // 登录\r\n  wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        if (res.code) {\r\n          api.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n              wx.setStorageSync('access_token', res.access_token)\r\n          }).catch(error=>{\r\n            console.log(error)\r\n          })\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })这里需要多提的一点是关于会话维持的方案，就是如何让服务器端知道访问接口的是谁。笔者提供两个办法：通过wx.request()在header中强行组装cookie字符串，来实现传统浏览器上用cookie维持会话的效果使用access_token的方式，比如jwt笔者选择的是第二种，通过后端的登录接口返回token，然后将token存入Storage，然后在发起请求的时候将token封装到http请求体中。 两种方案都可行，读者们可根据自己情况自行实现。 由于wx.request()方法发起请求比较麻烦，还需要处理会话逻辑，所以建议读者们还是进行一次封装，下边贴上笔者的代码：在utils文件夹中创建request.js文件const domain = \"https://cdx.tyhub.com\"\r\nfunction GET(url, params) {\r\n  return request('GET', url, params)\r\n}\r\nfunction POST(url, params) {\r\n  return request('POST', url, params)\r\n}\r\nfunction request(method, url, params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: domain + url,\r\n      data: params,\r\n      method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': 'bearer' + ' ' + wx.getStorageSync('access_token'),\r\n      },\r\n      success(res) {\r\n        if (res.data.code === 100) {\r\n          let resData = res.data.data\r\n          if (!resData) {\r\n            resData = ''\r\n          }\r\n          resolve(resData)\r\n        } else {\r\n          let err = {\r\n            code: res.data.code,\r\n            msg: res.data.msg\r\n          }\r\n          reject(err)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  get: GET,\r\n  post: POST\r\n}使用const api = require('../../utils/request')\r\n...\r\napi.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n     wx.setStorageSync('access_token', res.access_token)\r\n }).catch(error=>{\r\n   console.log(error)\r\n })至此，登录逻辑便已完成，是不是觉得小程序开发也不过如此呢？由于篇幅有限，今天就分享到这啦，后续我将继续和看官们一起探究以下小程序开发的话题图片上传表单提交级联选择器的实现如何使用iconfont图标微信支付模板消息....欢迎笔者持续关注，也欢迎笔者私信告知我其他疑问，我尽量都一一分享，知无不言，言无不尽。不是结束的结语打波小小的广告，个人开发的找对象小程序“佛系处对象”已经顺利上线，欢迎笔者看官们扫码体验，如果脱单了记得通知我哟！最后祝大家在事业和爱情的“战场中都能脱颖而出，顺利吃鸡！"}
{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
